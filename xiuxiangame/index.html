<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>ä»™é€”æ”¾ç½® Demo</title>
  <style>
/* ====== é€šç”¨å¸ƒå±€ & èƒŒæ™¯ ====== */
body {
  font-family: "Microsoft YaHei", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: radial-gradient(circle at top, #1b2340, #05060a);
  color: #f3f3f3;
  display: flex;
  justify-content: center;
  padding: 24px 12px;
}

.app-container {
  width: 100%;
  max-width: 520px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ====== é¡¶éƒ¨æ ‡é¢˜æ  ====== */
.top-bar {
  text-align: center;
  margin-bottom: 8px;
}

h1 {
  margin-bottom: 4px;
  letter-spacing: 2px;
  font-size: 24px;
}

.subtitle {
  font-size: 13px;
  color: #b6c1ff;
  margin-bottom: 4px;
}

.player-info {
  font-size: 13px;
  color: #d3d6ff;
}

/* ====== ä¸»ä½“åŒºåŸŸ ====== */
.main-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

/* çŠ¶æ€é¢æ¿ */
.stats {
  margin: 10px 0 10px;
  text-align: center;
  line-height: 1.6;
  padding: 12px 18px;
  border-radius: 12px;
  background: rgba(15, 20, 40, 0.9);
  box-shadow: 0 0 18px rgba(0, 0, 0, 0.45);
  border: 1px solid rgba(120, 150, 255, 0.4);
  width: 100%;
}

#realm {
  font-weight: bold;
  color: #ffd56b;
}

.stats-actions {
  margin-top: 6px;
  display: flex;
  justify-content: center;
  gap: 8px;
}

/* æŒ‰é’®æ ·å¼ */
button {
  padding: 10px 16px;
  margin: 6px 0;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  font-size: 14px;
  background: linear-gradient(120deg, #3a8bff, #7a5cff);
  color: #fff;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
  transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.2s ease;
}

button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
}

button:active:not(:disabled) {
  transform: translateY(1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-main {
  font-size: 18px;
  padding: 12px 24px;
  margin: 12px 0 10px;
}

.btn-small {
  padding: 6px 10px;
  font-size: 12px;
  margin: 0;
}

/* é€šç”¨åŠŸèƒ½é¢æ¿å¡ç‰‡ */
.panel {
  background: rgba(12, 16, 32, 0.95);
  border-radius: 14px;
  padding: 16px;
  margin-top: 8px;
  width: 100%;
  box-shadow: 0 0 14px rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(90, 120, 220, 0.7);
}

.panel h2 {
  margin-top: 0;
  font-size: 18px;
  color: #e9f0ff;
  display: flex;
  align-items: center;
  gap: 6px;
}

.panel h2::before {
  content: "âœ¦";
  font-size: 14px;
  color: #ffd56b;
}

.upgrade {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 6px 0;
}

.upgrade-info {
  font-size: 13px;
}

.hint {
  font-size: 12px;
  color: #9aa0c6;
  margin-top: 8px;
  line-height: 1.5;
}

/* å…­ç»´è¡¨æ ¼ */
.stats-grid {
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 13px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.stat-right {
  display: flex;
  align-items: center;
  gap: 4px;
}

.btn-plus {
  padding: 2px 8px;
  font-size: 11px;
  margin: 0;
  border-radius: 999px;
  background: linear-gradient(120deg, #5ac8fa, #007aff);
}

/* çµæ ¹è¯´æ˜è¡¨ */
.ling-root-table {
  font-size: 13px;
  margin-top: 8px;
}

.ling-root-row {
  display: flex;
  justify-content: space-between;
  margin: 2px 0;
}

/* æ¸¸å†æ—¥å¿— */
#battleLog {
  margin-top: 8px;
  max-height: 220px;
  overflow-y: auto;
  font-size: 12px;
  line-height: 1.5;
  background: rgba(5, 8, 20, 0.85);
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(120, 150, 255, 0.3);
}

/* åº•éƒ¨å¯¼èˆª */
.bottom-nav {
  margin-top: 16px;
  padding: 8px 10px;
  border-radius: 18px;
  background: rgba(10, 12, 24, 0.95);
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: space-around;
  align-items: center;
}

.nav-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 11px;
  color: #9aa0c6;
}

.nav-item.active {
  color: #ffd56b;
}

.nav-icon {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: radial-gradient(circle, #384173, #151728);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  margin-bottom: 4px;
}

/* å¼€å±€è¾“å…¥é“å·ç•Œé¢ */
.start-screen {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.82);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.start-card {
  background: rgba(10, 12, 30, 0.98);
  border-radius: 16px;
  padding: 20px 18px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 0 24px rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(120, 150, 255, 0.8);
  text-align: center;
}

.start-card h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 20px;
}

.start-card p {
  font-size: 13px;
  color: #c0c6ff;
  margin-bottom: 10px;
}

.start-card input {
  width: 85%;
  padding: 8px 12px;
  border-radius: 999px;
  border: none;
  outline: none;
  margin: 8px 0 14px;
  font-size: 14px;
}

.start-card .tip {
  font-size: 12px;
  color: #8f94c9;
  margin-bottom: 10px;
}

/* æ¸¸å†ç»“ç®— & éšæœºäº‹ä»¶å¼¹å±‚ */
.overlay-screen {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.78);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 110;
}

.result-card {
  background: rgba(10, 12, 30, 0.98);
  border-radius: 16px;
  padding: 18px 16px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 0 24px rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(200, 180, 120, 0.8);
  text-align: left;
}

.result-card h2 {
  margin: 0 0 8px;
  font-size: 18px;
}

.result-summary {
  font-size: 13px;
  color: #f5f5f5;
  margin-bottom: 8px;
}

.result-drops {
  font-size: 13px;
  color: #ffd56b;
  margin-bottom: 8px;
}

.result-extra {
  font-size: 12px;
  color: #d6dcff;
  margin-bottom: 8px;
}

.result-random {
  font-size: 12px;
  color: #c0c6ff;
  margin-bottom: 10px;
}

/* å¤§å±å¹•ï¼ˆå¯é€‰ï¼‰ */
@media (min-width: 900px) {
  .app-container {
    max-width: 620px;
  }
}
  </style>
</head>
<body>

  <!-- å¼€å±€å‘½å -->
  <div id="startScreen" class="start-screen">
    <div class="start-card">
      <h2>è¸å…¥ä¿®ä»™ä¹‹è·¯</h2>
      <p>è¯·ä¸ºè‡ªå·±å–ä¸€ä¸ªé“å·ï¼š</p>
      <input id="playerNameInput" type="text" placeholder="ä¾‹å¦‚ï¼šæ— åæ•£ä¿® / é’å±±æ•£äºº" />
      <div class="tip">å¼€å§‹ä¿®ç‚¼åï¼Œå°†éšæœºè§‰é†’ä¸€ç»„çµæ ¹ï¼ˆå¯èƒ½ä¸ºç¨€æœ‰å•çµæ ¹æˆ–åŒäº”è¡Œçµæ ¹ï¼‰ã€‚</div>
      <button id="startGameBtn">å¼€å§‹ä¿®ç‚¼</button>
    </div>
  </div>

  <!-- æ¸¸å†ç»“ç®— / éšæœºäº‹ä»¶ -->
  <div id="battleResultOverlay" class="overlay-screen">
    <div class="result-card">
      <h2 id="resultTitle">æ¸¸å†ç»“æœ</h2>
      <div id="resultSummary" class="result-summary"></div>
      <div id="resultDrops" class="result-drops"></div>
      <div id="resultExtra" class="result-extra"></div>
      <div id="randomEvent" class="result-random"></div>
      <button id="closeResultBtn">è¿”å›</button>
    </div>
  </div>

  <div class="app-container" id="appContainer">
    <!-- é¡¶éƒ¨ -->
    <div class="top-bar">
      <h1>ä»™é€”æ”¾ç½® Â· Demo</h1>
      <div class="subtitle">ä»å‡¡äººå¼€å§‹ï¼Œæ¯ç§’å¸æ”¶ 0.1 ç‚¹çœŸæ°”ï¼Œè¸ä¸Šä¿®ä»™ä¹‹è·¯</div>
      <div class="player-info">
        é“å·ï¼š<span id="playerName">æœªå‘½å</span> Â· çµæ ¹ï¼š<span id="lingRootName">æœªè§‰é†’</span>
      </div>
    </div>

    <!-- ä¸»åŒºåŸŸï¼šå¤šé¡µé¢ -->
    <div class="main-area">
      <!-- ä¿®ç‚¼é¡µ -->
      <div id="pageCultivation" style="width:100%;">
        <div class="stats">
          <div>å½“å‰çœŸæ°”ï¼š<span id="qi">0.0</span></div>
          <div>æ¯ç§’ä¿®ä¸ºå¢é•¿ï¼š<span id="qps">0.0</span> / ç§’</div>
          <div>æ¯æ¬¡æ‰“åè·å¾—ï¼š<span id="qpc">1.0</span> çœŸæ°”</div>
          <div>å½“å‰å¢ƒç•Œï¼š<span id="realm">å‡¡äºº</span></div>
          <div>
            å†ç»ƒå€¼ï¼š<span id="expMainSpan">0</span>
            ï¼ˆçªç ´éœ€æ±‚ï¼š<span id="expReqSpan">â€”</span>ï¼‰
          </div>
          <div class="hint">
            å¢ƒç•Œï¼šå‡¡äºº â†’ è¾Ÿè°· â†’ ç‚¼ä½“ â†’ ç»ƒæ°” â†’ ç­‘åŸº â†’ é‡‘ä¸¹ â†’ å…ƒå©´ â†’ å‡ºçª â†’ å¤§ä¹˜ â†’ æ¸¡åŠ« â†’ åŒ–ç¥ â†’ ä»™ç­ã€‚<br>
            æ¯ä¸ªã€Œå¤§åœ†æ»¡ã€çªç ´åˆ°ä¸‹ä¸€å¤§å¢ƒç•Œï¼Œéœ€è¦è¶³å¤Ÿçš„å†ç»ƒå€¼å¹¶æ‰‹åŠ¨çªç ´ã€‚
          </div>
          <div class="stats-actions">
            <button id="breakthroughBtn" class="btn-small">çªç ´å¢ƒç•Œ</button>
            <button id="saveBtn" class="btn-small">æ‰‹åŠ¨ä¿å­˜</button>
            <button id="resetBtn" class="btn-small">æ¸…ç©ºé‡ä¿®</button>
          </div>
        </div>

        <button id="cultivateBtn" class="btn-main">æ‰“ååçº³ï¼ˆè·å¾—çœŸæ°”ï¼‰</button>

        <div class="panel">
          <h2>ä¿®ä¸ºä¸å±æ€§</h2>
          <div class="hint">
            æ¯æ¬¡è·å¾—çœŸæ°”ï¼Œæœ‰ä¸€å®šæ¦‚ç‡è·å¾—ã€Œèƒ½åŠ›ç‚¹ã€ï¼Œå¯ç”¨äºè‡ªç”±åŠ ç‚¹ï¼ˆæ¦‚ç‡è¾ƒä½ï¼Œä¸»è¦é å¢ƒç•Œè‡ªåŠ¨æˆé•¿ï¼‰ã€‚<br>
            å¯åˆ†é…èƒ½åŠ›ç‚¹ï¼š<span id="abilityPoints">0</span>
          </div>
          <div class="hint">
            å†ç»ƒå€¼ï¼ˆæ¸¸å†ç»éªŒï¼‰ï¼š<span id="experienceSpan">0</span>
            ï¼ˆå½“å‰é¢å¤–ä¼¤å®³åŠ æˆï¼š<span id="experienceBuffSpan">0</span>%ï¼‰
          </div>
          <div class="hint">
            å½“å‰çµçŸ³å‚¨é‡ï¼š<span id="spiritStonesSpan">0</span>
          </div>
          <div class="stats-grid">
            <div class="stat-row">
              <span>åŠ›é‡ï¼ˆæ”»å‡»ä¼¤å®³ï¼‰</span>
              <span class="stat-right">
                <span id="statPower">0</span>
                <button class="btn-plus" data-stat="power">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>ä½“è´¨ï¼ˆç”Ÿå‘½ã€é˜²å¾¡ï¼‰</span>
              <span class="stat-right">
                <span id="statPhysique">0</span>
                <button class="btn-plus" data-stat="physique">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>èº«æ³•ï¼ˆé—ªé¿ã€é€Ÿåº¦ï¼‰</span>
              <span class="stat-right">
                <span id="statAgility">0</span>
                <button class="btn-plus" data-stat="agility">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>ç¥è¯†ï¼ˆè“é‡ã€ç²¾ç¥ï¼‰</span>
              <span class="stat-right">
                <span id="statSpirit">0</span>
                <button class="btn-plus" data-stat="spirit">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>æ ¹éª¨ï¼ˆä½“é­„ã€éŸ§æ€§ï¼‰</span>
              <span class="stat-right">
                <span id="statRoot">0</span>
                <button class="btn-plus" data-stat="root">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>æ°”è¿ï¼ˆæœºç¼˜ã€æ‰è½ï¼‰</span>
              <span class="stat-right">
                <span id="statLuck">0</span>
                <button class="btn-plus" data-stat="luck">+</button>
              </span>
            </div>
          </div>
        </div>

        <div class="panel">
          <h2>çµæ ¹å¤©èµ‹</h2>
          <div class="hint">
            çµæ ¹ä¸ç›´æ¥æ”¹å˜æˆ˜æ–—æ•°å€¼ï¼Œä½†ä¼šæå¤§å½±å“ä¿®ç‚¼é€Ÿåº¦ã€èƒ½åŠ›ç‚¹æ‰è½ä¸å¥‡é‡è§¦å‘ã€‚<br>
            å½“å‰çµæ ¹ç³»ç»ŸåŠ æˆï¼š<span id="lingRootBonusText">ä¿®ç‚¼é€Ÿåº¦ +0% Â· èƒ½åŠ›ç‚¹ +0% Â· å¥‡é‡æƒé‡ +0%</span>
          </div>
          <div id="lingRootTable" class="ling-root-table"></div>
        </div>
      </div>

      <!-- æ¸¸å†é¡µ -->
      <div id="pageBattle" style="width:100%; display:none;">
        <div class="panel">
          <h2>æ¸¸å† Â· è¯•ç‚¼</h2>
          <div id="playerBattleStats" class="hint">å°šæœªè¸å…¥ä¿®è¡Œï¼Œå±æ€§æœªçŸ¥ã€‚</div>
          <div class="hint">
            æ¸¸å†ç›®çš„åœ°ï¼š
            <select id="mapSelect"></select>
          </div>
          <div class="hint">
            ä¸åŒåœ°ç‚¹æ•Œäººå¢ƒç•Œä¸åŒï¼Œè·å¾—çš„çœŸæ°” / å†ç»ƒ / çµçŸ³å¥–åŠ±ä¹Ÿä¸åŒã€‚æ•Œäººè¶Šæ¥è¿‘ä½ å½“å‰å¢ƒç•Œï¼Œå¥–åŠ±è¶Šé«˜ã€‚
          </div>
          <div class="hint">
            <label>
              <input type="checkbox" id="autoBattleToggle">
              è‡ªåŠ¨æˆ˜æ–—ç»“ç®—ï¼ˆåœ¨ä¿®ç‚¼ / å¸‚é›†ç•Œé¢æ—¶ä¸å¼¹å‡ºç»“ç®—çª—å£ï¼‰
            </label>
          </div>
          <button id="startBattleBtn" class="btn-main">å¼€å§‹æ¸¸å†è¯•ç‚¼</button>
          <div id="battleResult" class="hint"></div>
          <div id="battleLog"></div>
        </div>
      </div>

      <!-- å¸‚é›†é¡µ -->
      <div id="pageShop" style="width:100%; display:none;">
        <div class="panel">
          <h2>çµçŸ³å¸‚é›† Â· æ´åºœ</h2>
          <div class="hint">
            å½“å‰çµçŸ³ï¼š<span id="shopSpiritStones">0</span><br>
            æ´åºœä¼šè‡ªåŠ¨å¸æ”¶å¤©åœ°çµæ°”ï¼Œæ˜¯æŒ‚æœºä¿®ç‚¼çš„æ ¸å¿ƒã€‚
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              è´­ä¹°æ´åºœï¼ˆæ•°é‡å åŠ ï¼‰<br>
              ä»·æ ¼ï¼š<span id="caveCost">0</span> çµçŸ³<br>
              æ´åºœæ•°é‡ï¼š<span id="caveCount">0</span>
            </div>
            <button id="buyCaveBtn">è´­ä¹°æ´åºœ</button>
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              æ´åºœå“è´¨ï¼š<span id="caveQualitySpan">ç®€é™‹æ´åºœ</span><br>
              å½“å‰æ€»æ´åºœåŠ æˆï¼š<span id="caveQpsSpan">0.0</span> çœŸæ°”/ç§’<br>
              å“è´¨å‡çº§æ¶ˆè€—ï¼š<span id="caveUpgradeCost">0</span> çµçŸ³
            </div>
            <button id="upgradeCaveBtn">å‡çº§æ´åºœå“è´¨</button>
          </div>
          <div class="hint">
            å“è´¨è¶Šé«˜ï¼Œæ¯ä¸€åº§æ´åºœæä¾›çš„çœŸæ°”/ç§’è¶Šå¤šã€‚éƒ¨åˆ†æ¸¸å†å¥‡é‡ä¹Ÿå¯èƒ½ç›´æ¥æå‡æ´åºœå“è´¨ã€‚
          </div>
        </div>

        <div class="panel">
          <h2>çµçŸ³å¸‚é›† Â· ä¸¹è¯</h2>
          <div class="hint">
            ä¸¹è¯ä¸»è¦æå‡æ‰“åæ—¶çš„çœŸæ°”æ”¶ç›Šï¼Œæ˜¯å‰æœŸæå‡ä¿®ä¸ºé€Ÿåº¦çš„é‡è¦æ–¹å¼ã€‚
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              è´­ä¹°èšæ°”æ•£ä¸€å±‚ï¼ˆæå‡æ‰“åæ”¶ç›Šï¼‰<br>
              ä»·æ ¼ï¼š<span id="pillCost">0</span> çµçŸ³<br>
              ä¸¹è¯å±‚æ•°ï¼š<span id="pillLevel">1</span>
            </div>
            <button id="buyPillBtn">è´­ä¹°ä¸¹è¯</button>
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              ä¸¹è¯å“è´¨ï¼š<span id="pillQualitySpan">å‡¡å“èšæ°”æ•£</span><br>
              å“è´¨å‡çº§æ¶ˆè€—ï¼š<span id="pillUpgradeCost">0</span> çµçŸ³
            </div>
            <button id="upgradePillBtn">å‡çº§ä¸¹è¯å“è´¨</button>
          </div>
          <div class="hint">
            å“è´¨è¶Šé«˜ï¼Œæ¯ä¸€å±‚ä¸¹è¯æä¾›çš„é¢å¤–æ‰“åçœŸæ°”è¶Šå¤šã€‚æœªæ¥å¯ä»¥åœ¨æ­¤æ‰©å±•æ›´å¤šä¸¹è¯ä¸åŠŸæ³•ã€‚
          </div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨å¯¼èˆª -->
    <div class="bottom-nav">
      <div class="nav-item active" data-page="cultivation">
        <div class="nav-icon">â›°ï¸</div>
        <div class="nav-label">ä¿®ç‚¼</div>
      </div>
      <div class="nav-item" data-page="battle">
        <div class="nav-icon">ğŸ§­</div>
        <div class="nav-label">æ¸¸å†</div>
      </div>
      <div class="nav-item" data-page="shop">
        <div class="nav-icon">ğŸ›’</div>
        <div class="nav-label">å¸‚é›†</div>
      </div>
    </div>
  </div>

  <script>
    /* ========== çµæ ¹è®¾å®š & å±‚çº§åŠ æˆï¼ˆåªå½±å“ä¿®ç‚¼ & å¥‡é‡ï¼‰ ========== */

    const LING_ROOTS = [
      // T1
      { id: 'cause',  name: 'å› æœçµæ ¹',  short: 'å› ', tierGroup: 'T1', type: 'special',
        desc: 'ä»¥å› æœä¸ºçº¿ï¼Œç‰µåŠ¨ç»“æœã€‚é€‚åˆã€Œå¤©å‘½æ”¹å†™ã€ã€Œç»“ç•Œåˆ¤å†³ã€ç­‰é«˜ç«¯åŠŸæ³•è·¯çº¿ã€‚' },
      { id: 'time',   name: 'æ—¶é—´çµæ ¹',  short: 'æ—¶', tierGroup: 'T1', type: 'special',
        desc: 'æ„ŸçŸ¥æ—¶é—´æµé€Ÿå˜åŒ–ï¼Œæœªæ¥å¯ä¿®ä¹ ã€Œæ—¶åœã€ã€Œå›æº¯ã€ç­‰é€†å¤©æœ¯å¼ã€‚' },
      { id: 'space',  name: 'ç©ºé—´çµæ ¹',  short: 'ç©º', tierGroup: 'T1', type: 'special',
        desc: 'å¤©ç”Ÿä¸ç©ºé—´æœ‰äº²å’Œï¼Œå¯æŒæ¡ç¬ç§»ã€æŠ˜å ç©ºé—´ã€é¢†åŸŸå‹ç¼©ç­‰èƒ½åŠ›ã€‚' },

      // T2
      { id: 'holy',   name: 'åœ£çµæ ¹',    short: 'åœ£', tierGroup: 'T2', type: 'special',
        desc: 'ç§©åºä¸åº‡æŠ¤çš„è±¡å¾ï¼Œåæ²»ç–—ã€æŠ¤ç›¾ã€å›¢é˜Ÿå¢ç›Šç­‰åœ£èŒè·¯çº¿ã€‚' },
      { id: 'realm',  name: 'ç•Œçµæ ¹',    short: 'ç•Œ', tierGroup: 'T2', type: 'special',
        desc: 'æ“…é•¿æ„ç­‘é¢†åŸŸä¸ç»“ç•Œï¼Œå°†æ¥å¯é•‡å®ˆä¸€æ–¹å°ä¸–ç•Œã€‚' },
      { id: 'light',  name: 'å…‰çµæ ¹',    short: 'å…‰', tierGroup: 'T2', type: 'special',
        desc: 'æŒæ§å…‰ä¸é€Ÿåº¦ï¼Œåå‡€åŒ–ã€çˆ†å‘ä¸é«˜é€Ÿæ–©å‡»ã€‚' },
      { id: 'dark',   name: 'æš—çµæ ¹',    short: 'æš—', tierGroup: 'T2', type: 'special',
        desc: 'ä¸é˜´å½±ã€è…èš€ã€æ½œè¡Œç›¸ä¼´ï¼Œå¯ä¿®æš—å½±æ½œä¼ã€è¯…å’’ç­‰æ­¦æŠ€ã€‚' },

      // T3
      { id: 'dream',  name: 'æ¢¦çµæ ¹',    short: 'æ¢¦', tierGroup: 'T3', type: 'special',
        desc: 'æ¸¸èµ°ç°å®ä¸æ¢¦å¢ƒï¼Œé€‚åˆå¹»æœ¯ã€å¿ƒå¢ƒæ‰°ä¹±ã€å¿ƒé­”åŒ–è§£æ–¹å‘ã€‚' },
      { id: 'spirit', name: 'çµçµæ ¹',    short: 'çµ', tierGroup: 'T3', type: 'special',
        desc: 'çµè§‰æ•é”ï¼Œå¯¹å¤©åœ°æ°”æœºæä¸ºæ•æ„Ÿï¼Œæ“…é•¿æ¢æŸ¥å±æœºä¸æœºç¼˜ã€‚' },
      { id: 'heart',  name: 'å¿ƒçµæ ¹',    short: 'å¿ƒ', tierGroup: 'T3', type: 'special',
        desc: 'å¿ƒæ€§åšéŸ§ï¼Œæƒ…ç»ªå…±é¸£å¼ºçƒˆï¼Œé€‚åˆæ„å¿—å‹åˆ¶ã€æ–—å¿—ç‡ƒçƒ§è·¯çº¿ã€‚' },

      // T4
      { id: 'ice',    name: 'å†°çµæ ¹',    short: 'å†°', tierGroup: 'T4', type: 'special',
        desc: 'ä¸»æŒå¯’å†°å°é”ä¸å‡é€Ÿï¼Œæˆ˜æ–—è¡¨ç°å¼ºåŠ¿ã€‚' },
      { id: 'thunder',name: 'é›·çµæ ¹',    short: 'é›·', tierGroup: 'T4', type: 'special',
        desc: 'é›·éœ†ä¸‡é’§ï¼Œåå¼ºçˆ†å‘ä¸éº»ç—¹æ‰“æ–­ï¼Œæ˜¯å‰æœŸæˆ˜æ–—åˆ©å™¨ã€‚' },

      // T5 äº”è¡Œï¼Œå¯ç»„åˆä¸ºåŒçµæ ¹
      { id: 'metal',  name: 'é‡‘çµæ ¹',    short: 'é‡‘', tierGroup: 'T5', type: 'basic',
        desc: 'é”‹é”æ”»ä¼ä¹‹é“ï¼Œé€‚åˆå‰‘ä¿®ã€æªä¿®ç­‰é”‹é”æµæ´¾ã€‚' },
      { id: 'wood',   name: 'æœ¨çµæ ¹',    short: 'æœ¨', tierGroup: 'T5', type: 'basic',
        desc: 'ç”Ÿé•¿ä¸æ²»æ„ˆä¹‹æœ¬æºï¼Œæ“…é•¿å›å¤ä¸è—¤è”“ç¼ ç»•ã€‚' },
      { id: 'water',  name: 'æ°´çµæ ¹',    short: 'æ°´', tierGroup: 'T5', type: 'basic',
        desc: 'æŸ”éŸ§å¤šå˜ï¼Œå¯å€Ÿæ°´åŠ¿å¸åŠ›ï¼Œåèº«æ³•ä¸åŒ–è§£ã€‚' },
      { id: 'fire',   name: 'ç«çµæ ¹',    short: 'ç«', tierGroup: 'T5', type: 'basic',
        desc: 'çƒ­çƒˆçˆ†è£‚ï¼Œåçˆ†å‘è¾“å‡ºä¸æŒç»­ç¼çƒ§ã€‚' },
      { id: 'earth',  name: 'åœŸçµæ ¹',    short: 'åœŸ', tierGroup: 'T5', type: 'basic',
        desc: 'ç¨³å›ºåšé‡ï¼Œé€‚åˆé˜²å¾¡ã€å²©ç›¾ã€æŠ¤ä½“ç­‰è·¯çº¿ã€‚' }
    ];

    const LING_TIER_META = {
      none:       { label: 'æ— çµæ ¹åŠ æˆ',         qiMult: 1.0,  abilityMult: 1.0, eventMult: 1.0 },
      T1:         { label: 'T1 è¶…é™çµæ ¹',       qiMult: 3.0,  abilityMult: 2.5, eventMult: 2.5 },
      T2:         { label: 'T2 é«˜ç»´è§„åˆ™çµæ ¹',   qiMult: 2.2,  abilityMult: 1.4, eventMult: 1.6 },
      T3:         { label: 'T3 çµæ€§/æ„è¯†çµæ ¹',  qiMult: 2.0,  abilityMult: 1.0, eventMult: 1.4 },
      T4:         { label: 'T4 è‡ªç„¶æˆ˜æ–—çµæ ¹',   qiMult: 1.4,  abilityMult: 1.0, eventMult: 1.0 },
      T5_single:  { label: 'T5 å•äº”è¡Œçµæ ¹',     qiMult: 1.0,  abilityMult: 1.0, eventMult: 1.0 },
      T5_double:  { label: 'T5 åŒäº”è¡Œçµæ ¹',     qiMult: 1.25, abilityMult: 1.0, eventMult: 1.0 }
    };

    function getBasicRoots()  { return LING_ROOTS.filter(r => r.type === 'basic'); }
    function getSpecialRoots(){ return LING_ROOTS.filter(r => r.type === 'special'); }

    function getDualBasicRelation(roots) {
      if (!roots || roots.length !== 2) return { type: 'neutral', label: 'T5 åŒçµæ ¹', descExtra: '' };
      const [r1, r2] = roots;
      if (r1.type !== 'basic' || r2.type !== 'basic') return { type: 'neutral', label: 'T5 åŒçµæ ¹', descExtra: '' };
      const a = r1.id, b = r2.id;

      function match(p1, p2) {
        return (a === p1 && b === p2) || (a === p2 && b === p1);
      }

      // ç›¸ç”Ÿï¼šæœ¨ç«ã€ç«åœŸã€åœŸé‡‘ã€é‡‘æ°´ã€æ°´æœ¨
      if (match('wood', 'fire') || match('fire', 'earth') || match('earth', 'metal')
        || match('metal', 'water') || match('water', 'wood')) {
        return {
          type: 'synergy',
          label: 'T4.5 ç›¸ç”ŸåŒçµæ ¹',
          descExtra: 'ä¸¤ç§äº”è¡Œç›¸ç”Ÿï¼Œç«æ¶¨æœ¨åŠ¿ï¼Œæœ¨ç¥ç«å¨ï¼Œä½¿å¾—èƒ½åŠ›ç‚¹è·å–ç•¥æœ‰æå‡ã€‚'
        };
      }
      // ç›¸å…‹ï¼šé‡‘æœ¨ï¼Œæœ¨åœŸï¼ŒåœŸæ°´ï¼Œæ°´ç«ï¼Œç«é‡‘
      if (match('metal', 'wood') || match('wood', 'earth') || match('earth', 'water')
        || match('water', 'fire') || match('fire', 'metal')) {
        return {
          type: 'clash',
          label: 'T5 ç›¸å…‹åŒçµæ ¹',
          descExtra: 'ä¸¤ç§äº”è¡Œç›¸å…‹ï¼Œä¿®è¡Œè·¯ä¸Šæ³¢æ¾œä¸æ–­ï¼Œå´æ›´å®¹æ˜“æ¿€å‘å‘½è¿æ³¢åŠ¨ä¸å¥‡é‡ã€‚'
        };
      }
      return { type: 'neutral', label: 'T5 åŒçµæ ¹', descExtra: 'ä¸¤ç§äº”è¡Œå¹¶å­˜ï¼Œæ—¢æœ‰å¤šæ ·å˜åŒ–ï¼Œä¹Ÿéœ€è°¨æ…è°ƒå’Œã€‚' };
    }

    function getLingRootTierMeta() {
      if (!lingRoots || lingRoots.length === 0) return LING_TIER_META.none;

      const hasSpecial = lingRoots.some(r => r.type === 'special');
      if (hasSpecial) {
        const order = ['T1', 'T2', 'T3', 'T4'];
        let bestTier = 'T4';
        let bestIndex = order.length;
        lingRoots.forEach(r => {
          if (r.type === 'special') {
            const idx = order.indexOf(r.tierGroup);
            if (idx !== -1 && idx < bestIndex) {
              bestIndex = idx;
              bestTier = r.tierGroup;
            }
          }
        });
        const meta = { ...LING_TIER_META[bestTier] };
        return meta;
      } else {
        if (lingRoots.length >= 2) {
          const meta = { ...LING_TIER_META.T5_double };
          const rel = getDualBasicRelation(lingRoots);
          if (rel.type === 'synergy') {
            meta.abilityMult *= 1.2; // ç›¸ç”Ÿï¼šèƒ½åŠ›ç‚¹ç•¥å¢
          } else if (rel.type === 'clash') {
            meta.eventMult *= 1.2;   // ç›¸å…‹ï¼šå¥‡é‡æ¦‚ç‡ç•¥å¢
          }
          return meta;
        }
        return LING_TIER_META.T5_single;
      }
    }

    function getLingRootDisplayName() {
      if (!lingRoots || lingRoots.length === 0) return 'æœªè§‰é†’';
      if (lingRoots.length === 1) return lingRoots[0].name;
      const bothBasic = lingRoots.every(r => r.type === 'basic');
      if (bothBasic) {
        return `${lingRoots[0].short}${lingRoots[1].short}åŒçµæ ¹`;
      }
      return lingRoots.map(r => r.name).join(' / ');
    }

    // æŠ½çµæ ¹ï¼š15% ç¨€æœ‰å•çµæ ¹ï¼›å…¶ä½™ä¸ºå•/åŒäº”è¡Œ
    function generateLingRoots() {
      const specialPool = getSpecialRoots();
      const basicPool = getBasicRoots();
      const roll = Math.random();

      if (roll < 0.15) {
        const idx = Math.floor(Math.random() * specialPool.length);
        return [specialPool[idx]];
      } else {
        const r2 = Math.random();
        if (r2 < 0.4) {
          const idx = Math.floor(Math.random() * basicPool.length);
          return [basicPool[idx]];
        } else {
          const idx1 = Math.floor(Math.random() * basicPool.length);
          let idx2 = Math.floor(Math.random() * basicPool.length);
          while (idx2 === idx1) idx2 = Math.floor(Math.random() * basicPool.length);
          return [basicPool[idx1], basicPool[idx2]];
        }
      }
    }

    /* ========== å¢ƒç•Œå®šä¹‰ï¼šå‡¡äºº + 11 ä¸ªå¤§å¢ƒç•Œï¼Œæ¯ä¸ªå‰ä¸­åå¤§åœ†æ»¡ ========= */

    const BIG_REALMS = ['å‡¡äºº','è¾Ÿè°·','ç‚¼ä½“','ç»ƒæ°”','ç­‘åŸº','é‡‘ä¸¹','å…ƒå©´','å‡ºçª','å¤§ä¹˜','æ¸¡åŠ«','åŒ–ç¥','ä»™ç­'];
    const REALM_SUFFIXES = ['å‰æœŸ','ä¸­æœŸ','åæœŸ','å¤§åœ†æ»¡'];
    const REALM_NAMES = [];
    const realmThresholds = [];

    REALM_NAMES[0] = 'å‡¡äºº';
    realmThresholds[0] = 0;

    for (let i = 1; i < BIG_REALMS.length; i++) {
      const base = Math.pow(10, i - 1) * 10; // 10,100,1000,10000,...
      const factors = [1, 2.5, 5, 9];        // 10/25/50/90, 100/250/500/900, ...
      for (let j = 0; j < 4; j++) {
        const stageIndex = (i - 1) * 4 + j + 1; // 1..4: è¾Ÿè°·, 5..8: ç‚¼ä½“, ...
        REALM_NAMES[stageIndex] = BIG_REALMS[i] + REALM_SUFFIXES[j];
        realmThresholds[stageIndex] = Math.floor(base * factors[j]);
      }
    }

    function getRealmNameFromStage(stage) {
      return REALM_NAMES[stage] || 'æœªçŸ¥å¢ƒç•Œ';
    }

    function getBigRealmIndex(stage) {
      if (stage <= 0) return -1;
      return Math.floor((stage - 1) / 4); // 0:è¾Ÿè°·,1:ç‚¼ä½“,...,10:ä»™ç­
    }

    function isBigRoundStage(stage) {
      return stage > 0 && stage % 4 === 0;
    }

    // 11 ä¸ªå¤§å¢ƒç•Œçš„å¤§åœ†æ»¡åŠ æˆï¼ˆæ•°å€¼å¯ç»§ç»­è°ƒï¼‰
    const REALM_BIG_BONUSES = [
      { power: 1,  physique: 2,  agility: 1,  spirit: 1,  root: 2,  luck: 0 }, // è¾Ÿè°·
      { power: 2,  physique: 3,  agility: 2,  spirit: 1,  root: 2,  luck: 1 }, // ç‚¼ä½“
      { power: 3,  physique: 3,  agility: 2,  spirit: 2,  root: 2,  luck: 1 }, // ç»ƒæ°”
      { power: 4,  physique: 4,  agility: 3,  spirit: 3,  root: 3,  luck: 1 }, // ç­‘åŸº
      { power: 5,  physique: 5,  agility: 3,  spirit: 4,  root: 3,  luck: 2 }, // é‡‘ä¸¹
      { power: 6,  physique: 6,  agility: 4,  spirit: 5,  root: 4,  luck: 2 }, // å…ƒå©´
      { power: 7,  physique: 7,  agility: 4,  spirit: 6,  root: 4,  luck: 3 }, // å‡ºçª
      { power: 8,  physique: 8,  agility: 5,  spirit: 7,  root: 5,  luck: 3 }, // å¤§ä¹˜
      { power: 9,  physique: 9,  agility: 5,  spirit: 8,  root: 5,  luck: 4 }, // æ¸¡åŠ«
      { power: 10, physique:10, agility: 6,  spirit: 9,  root: 6,  luck: 4 }, // åŒ–ç¥
      { power: 12, physique:12, agility: 7,  spirit:10,  root: 7,  luck: 5 }  // ä»™ç­
    ];

    const REALM_BIG_QI_BONUS = [
      0.02, 0.04, 0.06, 0.09, 0.12, 0.16, 0.20, 0.25, 0.30, 0.40, 0.50
    ];

    // æ¯ä¸ªå¤§å¢ƒå¤§åœ†æ»¡çªç ´åˆ°ä¸‹ä¸€å¤§å¢ƒç•Œæ‰€éœ€å†ç»ƒå€¼ï¼š50ã€500ã€5000ã€50000â€¦â€¦
    function getExpThresholdForBigRealmIndex(idx) {
      if (idx < 0) return 0;
      return 50 * Math.pow(10, idx); // 50,500,5000,50000,...
    }

    function getCurrentExpRequirementForBreak(stage, experience) {
      if (!isBigRoundStage(stage)) return 0;
      const idx = getBigRealmIndex(stage);
      return getExpThresholdForBigRealmIndex(idx);
    }

    /* ========== éšæœº flavor å¥å­ ========= */
    const RANDOM_EVENTS = [
      'ä½ åœ¨å½’é€”ä¸­å¶ç„¶æ„Ÿåº”åˆ°è¿œå¤„æœ‰çµè„‰æ³¢åŠ¨ï¼Œä½†ä¿®ä¸ºå°šæµ…ï¼Œåªå¾—è®°åœ¨å¿ƒé‡Œã€‚',
      'ä¸€åªçµå…½ä»èº«æ—æ è¿‡ï¼Œä¼¼ä¹å¯¹ä½ çš„çµæ ¹å¤šçœ‹äº†ä¸€çœ¼ï¼Œéšå³æ¶ˆå¤±åœ¨æ—é—´ã€‚',
      'å¤©ç©ºç‚¸å“ä¸€å£°é—·é›·ï¼Œä½ éšçº¦æ„Ÿåˆ°ä½“å†…çœŸæ°”éšä¹‹éœ‡åŠ¨ã€‚',
      'ä½ è·¯è¿‡ä¸€åº§åºŸå¼ƒçŸ³äº­ï¼ŒçŸ³ç¢‘ä¸Šçš„å¤å­—åœ¨ä½™å…‰ä¸­ä¼¼ä¹é—ªçƒäº†ä¸€ç¬ã€‚',
      'è¿œå¤„æœ‰ä¿®å£«é£å‰‘è€Œè¿‡ï¼Œæº…èµ·çš„çµå…‰åœ¨ä½ çœ¼ä¸­ç•™ä¸‹çŸ­æš‚æ®‹å½±ã€‚',
      'ä¸€é˜µå¾®é£æ‹‚è¿‡ï¼Œä½ ææƒšé—´å¬è§æœ‰äººåœ¨è€³è¾¹ä½å£°å¿µè¯µå¤ç»ã€‚'
    ];
    function getRandomEventText() {
      const idx = Math.floor(Math.random() * RANDOM_EVENTS.length);
      return RANDOM_EVENTS[idx];
    }

    /* ========== æ ¸å¿ƒçŠ¶æ€ ========== */

    let gameStarted = false;
    let currentPage = 'cultivation';
    let autoBattle = false;

    let qi = 0;
    let qiPerSecond = 0.1;   // ç”±åŸºç¡€ + æ´åºœ + å¢ƒç•ŒåŠ æˆç»„åˆ
    let qiPerClick = 1.0;    // ç”±åŸºç¡€ + ä¸¹è¯ç»„åˆ
    let realmStage = 0;

    const baseStats = {
      power: 5, physique: 5, agility: 5,
      spirit: 5, root: 5,    luck: 5
    };
    let stats = { ...baseStats };

    let abilityPoints = 0;
    let spiritStones = 0;
    let experience = 0;

    // æ´åºœ & ä¸¹è¯å“è´¨ / æ•°é‡
    let caveCount = 0;
    let caveQuality = 1;
    let pillLevel = 1;
    let pillQuality = 1;

    // ä¿®ç‚¼åŸºç¡€ï¼šè¢«å“è´¨å’Œå¢ƒç•Œä¿®æ­£
    let baseQiPerSecond = 0.1;
    let realmQpsBonus = 0;
    const caveQiPerBase = 0.2;
    let baseQiPerClick = 1.0;

    // ç©å®¶ & çµæ ¹
    let playerName = '';
    let lingRoots = [];

    // ç¥Â·/ä»™å·
    let godTitleUnlocked = false;
    let immortalTitle = '';
    let immortalTitleUnlocked = false;

    // æ¸¸å†ï¼ˆæˆ˜æ–—ï¼‰çŠ¶æ€
    let currentBattle = null;
    let battleTimerId = null;
    const BATTLE_TURN_DELAY = 300;
    const MAX_TURNS = 20;
    let currentMapId = 'map_0';

    /* ========== å¸‚é›†å“è´¨æ–‡æœ¬ä¸ä»·æ ¼ ========== */

    const CAVE_QUALITY_NAMES = ['ç®€é™‹æ´åºœ', 'æ™®é€šæ´åºœ', 'ä¸Šå“æ´åºœ', 'æå“æ´åºœ', 'ä»™å“æ´åºœ'];
    const PILL_QUALITY_NAMES = ['å‡¡å“èšæ°”æ•£', 'æ™®é€šèšæ°”æ•£', 'ä¸Šå“èšæ°”æ•£', 'æå“èšæ°”æ•£', 'ä»™å“èšæ°”æ•£'];
    const MAX_CAVE_QUALITY = 5;
    const MAX_PILL_QUALITY = 5;

    const caveBaseStoneCost = 5;
    const pillBaseStoneCost = 4;
    const caveUpgradeBaseCost = 20;
    const pillUpgradeBaseCost = 15;

    function getCaveQualityName() {
      const idx = Math.min(caveQuality - 1, CAVE_QUALITY_NAMES.length - 1);
      return CAVE_QUALITY_NAMES[idx];
    }
    function getPillQualityName() {
      const idx = Math.min(pillQuality - 1, PILL_QUALITY_NAMES.length - 1);
      return PILL_QUALITY_NAMES[idx];
    }

    function getCaveBuyCost() {
      return Math.floor(caveBaseStoneCost * Math.pow(1.5, caveCount));
    }
    function getCaveUpgradeCost() {
      return Math.floor(caveUpgradeBaseCost * Math.pow(2, caveQuality - 1));
    }
    function getPillBuyCost() {
      return Math.floor(pillBaseStoneCost * Math.pow(1.4, pillLevel - 1));
    }
    function getPillUpgradeCost() {
      return Math.floor(pillUpgradeBaseCost * Math.pow(2, pillQuality - 1));
    }

    function getCaveQps() {
      return caveCount * caveQiPerBase * (1 + 0.4 * (caveQuality - 1));
    }

    function recalcDerivedStats() {
      qiPerSecond =
        baseQiPerSecond +
        realmQpsBonus +
        getCaveQps();
      qiPerClick =
        baseQiPerClick +
        (pillLevel - 1) * (1 + 0.4 * (pillQuality - 1));
    }

    /* ========== åœ°å›¾ï¼ˆä¸ºæ¯ä¸ªå¢ƒç•Œç”Ÿæˆä¸€ä¸ªæ¸¸å†ç›®çš„åœ°ï¼‰ ========== */

    let MAPS = [];

    function generateMaps() {
      MAPS = [];
      for (let s = 0; s < REALM_NAMES.length; s++) {
        const stageName = REALM_NAMES[s];
        let rewardMult = 0.6 + s * 0.12;
        if (rewardMult > 6) rewardMult = 6;
        MAPS.push({
          id: 'map_' + s,
          name: `${stageName} Â· æ¸¸å†ä¹‹åœ°`,
          enemyStage: s,
          rewardMult
        });
      }
    }

    /* ========== DOM å¼•ç”¨ ========== */

    const qiSpan = document.getElementById('qi');
    const qpsSpan = document.getElementById('qps');
    const qpcSpan = document.getElementById('qpc');
    const realmSpan = document.getElementById('realm');

    const expMainSpan = document.getElementById('expMainSpan');
    const expReqSpan = document.getElementById('expReqSpan');
    const breakthroughBtn = document.getElementById('breakthroughBtn');

    const statPowerSpan = document.getElementById('statPower');
    const statPhysiqueSpan = document.getElementById('statPhysique');
    const statAgilitySpan = document.getElementById('statAgility');
    const statSpiritSpan = document.getElementById('statSpirit');
    const statRootSpan = document.getElementById('statRoot');
    const statLuckSpan = document.getElementById('statLuck');

    const abilityPointsSpan = document.getElementById('abilityPoints');
    const spiritStonesSpan = document.getElementById('spiritStonesSpan');
    const experienceSpan = document.getElementById('experienceSpan');
    const experienceBuffSpan = document.getElementById('experienceBuffSpan');

    const shopSpiritStonesSpan = document.getElementById('shopSpiritStones');

    const cultivateBtn = document.getElementById('cultivateBtn');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');
    const plusButtons = document.querySelectorAll('.btn-plus');

    const startScreen = document.getElementById('startScreen');
    const playerNameInput = document.getElementById('playerNameInput');
    const startGameBtn = document.getElementById('startGameBtn');
    const playerNameSpan = document.getElementById('playerName');
    const lingRootNameSpan = document.getElementById('lingRootName');
    const lingRootTableDiv = document.getElementById('lingRootTable');
    const lingRootBonusText = document.getElementById('lingRootBonusText');

    const pageCultivation = document.getElementById('pageCultivation');
    const pageBattle = document.getElementById('pageBattle');
    const pageShop = document.getElementById('pageShop');
    const navItems = document.querySelectorAll('.nav-item');

    // å¸‚é›†ç›¸å…³
    const caveCostSpan = document.getElementById('caveCost');
    const caveCountSpan = document.getElementById('caveCount');
    const caveQualitySpan = document.getElementById('caveQualitySpan');
    const caveUpgradeCostSpan = document.getElementById('caveUpgradeCost');
    const caveQpsSpan = document.getElementById('caveQpsSpan');

    const pillCostSpan = document.getElementById('pillCost');
    const pillLevelSpan = document.getElementById('pillLevel');
    const pillQualitySpan = document.getElementById('pillQualitySpan');
    const pillUpgradeCostSpan = document.getElementById('pillUpgradeCost');

    const buyCaveBtn = document.getElementById('buyCaveBtn');
    const upgradeCaveBtn = document.getElementById('upgradeCaveBtn');
    const buyPillBtn = document.getElementById('buyPillBtn');
    const upgradePillBtn = document.getElementById('upgradePillBtn');

    // æ¸¸å†
    const playerBattleStatsDiv = document.getElementById('playerBattleStats');
    const mapSelect = document.getElementById('mapSelect');
    const startBattleBtn = document.getElementById('startBattleBtn');
    const battleResultDiv = document.getElementById('battleResult');
    const battleLogDiv = document.getElementById('battleLog');
    const autoBattleToggle = document.getElementById('autoBattleToggle');

    const battleResultOverlay = document.getElementById('battleResultOverlay');
    const resultTitle = document.getElementById('resultTitle');
    const resultSummary = document.getElementById('resultSummary');
    const resultDrops = document.getElementById('resultDrops');
    const resultExtra = document.getElementById('resultExtra');
    const randomEventDiv = document.getElementById('randomEvent');
    const closeResultBtn = document.getElementById('closeResultBtn');

    const SAVE_KEY = 'xiuxianIdleSave_v7';

    /* ========== çµæ ¹ UI ========== */

    function updateLingRootUI() {
      lingRootNameSpan.textContent = getLingRootDisplayName();

      const meta = getLingRootTierMeta();
      const qiBonus      = ((meta.qiMult - 1) * 100).toFixed(0);
      const abilityBonus = ((meta.abilityMult - 1) * 100).toFixed(0);
      const eventBonus   = ((meta.eventMult - 1) * 100).toFixed(0);

      function fmt(v) {
        const n = Number(v);
        if (n === 0) return '+0%';
        return (n > 0 ? '+' : '') + n + '%';
      }
      lingRootBonusText.textContent =
        `ä¿®ç‚¼é€Ÿåº¦ ${fmt(qiBonus)} Â· èƒ½åŠ›ç‚¹ ${fmt(abilityBonus)} Â· å¥‡é‡æƒé‡ ${fmt(eventBonus)}`;

      lingRootTableDiv.innerHTML = '';
      if (!lingRoots || lingRoots.length === 0) {
        lingRootTableDiv.textContent = 'å°šæœªè§‰é†’çµæ ¹ã€‚';
        return;
      }

      // åŒäº”è¡Œçµæ ¹ï¼šåˆå¹¶å±•ç¤º
      if (lingRoots.length === 2 && lingRoots.every(r => r.type === 'basic')) {
        const [r1, r2] = lingRoots;
        const rel = getDualBasicRelation(lingRoots);

        const row1 = document.createElement('div');
        row1.className = 'ling-root-row';
        row1.innerHTML = `<span>${r1.short}${r2.short}åŒçµæ ¹</span><span>å±‚çº§ï¼š${rel.label}</span>`;
        lingRootTableDiv.appendChild(row1);

        const row2 = document.createElement('div');
        row2.className = 'ling-root-row';
        row2.innerHTML =
          `<span>èƒ½åŠ›å€¾å‘ï¼š</span><span>${r1.name} ä¸ ${r2.name} å¹¶å­˜ã€‚${rel.descExtra}</span>`;
        lingRootTableDiv.appendChild(row2);
      } else {
        // å•çµæ ¹ / ç¨€æœ‰çµæ ¹ï¼šé€ä¸ªå±•ç¤º
        lingRoots.forEach(r => {
          const row1 = document.createElement('div');
          row1.className = 'ling-root-row';
          row1.innerHTML = `<span>${r.name}</span><span>å±‚çº§ï¼š${r.tierGroup} Â· ç±»å‹ï¼š${r.type === 'special' ? 'ç¨€æœ‰' : 'äº”è¡Œ'}</span>`;
          lingRootTableDiv.appendChild(row1);

          const row2 = document.createElement('div');
          row2.className = 'ling-root-row';
          row2.innerHTML = `<span>èƒ½åŠ›å€¾å‘ï¼š</span><span>${r.desc}</span>`;
          lingRootTableDiv.appendChild(row2);
        });
      }

      const extra = document.createElement('div');
      extra.className = 'ling-root-row';
      extra.innerHTML = `<span>ç³»ç»ŸåŠ æˆï¼š</span><span>${getLingRootTierMeta().label}</span>`;
      lingRootTableDiv.appendChild(extra);
    }

    /* ========== å¢ƒç•ŒåŠ æˆï¼šæ¯é˜¶æ®µ/æ¯å¤§å¢ƒç•ŒåŠ æˆ ========= */

    function applyStageBonus(stage) {
      if (stage <= 0) return;
      const bigIdx = getBigRealmIndex(stage);
      const incBase = 1 + Math.floor(bigIdx / 2); // åæœŸå¢ƒç•Œæ¯å‡ä¸€çº§åŠ å¾—æ›´å¤š

      stats.power    += incBase;
      stats.physique += incBase + 1;
      stats.agility  += incBase;
      stats.spirit   += incBase;
      stats.root     += incBase + 1;
      stats.luck     += Math.max(1, Math.floor(incBase / 2));

      // åŒ–ç¥ç§°å· / ä»™ç­ä»™å·ï¼šåœ¨è¿›å…¥å¯¹åº”å¤§å¢ƒç•Œã€Œå‰æœŸã€æ—¶è§¦å‘
      if (stage % 4 === 1) {
        if (bigIdx === 9 && !godTitleUnlocked) {
          godTitleUnlocked = true;
          alert('ä½ å·²è¸å…¥ã€ŒåŒ–ç¥ã€å¢ƒç•Œï¼Œè·å¾—ç§°å·ï¼šç¥Â·ï¼ˆæ˜¾ç¤ºåœ¨é“å·å‰ï¼‰ã€‚');
        }
        if (bigIdx === 10 && !immortalTitleUnlocked) {
          immortalTitleUnlocked = true;
          const name = prompt('æ­å–œä½ æˆåŠŸæ™‹çº§ã€Œä»™ç­ã€ï¼è¯·ä¸ºè‡ªå·±å–ä¸€ä¸ªä»™å·ï¼ˆå°†æ˜¾ç¤ºåœ¨é“å·å‰ï¼‰ï¼š',
                              'æŸæŸä¸Šä»™');
          if (name && name.trim()) {
            immortalTitle = name.trim();
          }
        }
      }
    }

    function applyRealmBonus(stage) {
      if (stage <= 0) return;
      const idx = getBigRealmIndex(stage);
      if (idx < 0 || idx >= REALM_BIG_BONUSES.length) return;
      const bonus = REALM_BIG_BONUSES[idx];
      stats.power    += bonus.power;
      stats.physique += bonus.physique;
      stats.agility  += bonus.agility;
      stats.spirit   += bonus.spirit;
      stats.root     += bonus.root;
      stats.luck     += bonus.luck;
      realmQpsBonus  += REALM_BIG_QI_BONUS[idx] || 0;
      recalcDerivedStats();
    }

    /* ========== è‡ªåŠ¨çªç ´ & æ‰‹åŠ¨çªç ´ ========= */

    function checkBreakthrough() {
      let upgraded = false;
      while (realmStage < realmThresholds.length - 1) {
        const nextStage = realmStage + 1;
        if (qi < realmThresholds[nextStage]) break;
        if (isBigRoundStage(realmStage)) break; // å¤§åœ†æ»¡éœ€è¦æ‰‹åŠ¨çªç ´
        realmStage = nextStage;
        applyStageBonus(realmStage);
        if (isBigRoundStage(realmStage)) {
          applyRealmBonus(realmStage);
        }
        upgraded = true;
      }
      if (upgraded) {
        recalcDerivedStats();
      }
    }

    function canManualBreakthrough() {
      if (!gameStarted) return false;
      if (!isBigRoundStage(realmStage)) return false;
      if (realmStage >= realmThresholds.length - 1) return false;

      const expReq = getCurrentExpRequirementForBreak(realmStage, experience);
      if (experience < expReq) return false;

      const nextStage = realmStage + 1;
      if (qi < realmThresholds[nextStage]) return false;

      return true;
    }

    function doManualBreakthrough() {
      if (!canManualBreakthrough()) return;

      // ä»ç­‘åŸºå¤§åœ†æ»¡å¼€å§‹ï¼Œæœ‰å¤±è´¥å‡ ç‡ï¼šç­‘åŸºâ†’é‡‘ä¸¹ 1%ï¼Œé‡‘ä¸¹â†’å…ƒå©´ 2%ï¼Œä»¥æ­¤ç±»æ¨
      const bigIdxCurrent = getBigRealmIndex(realmStage); // è¾Ÿè°·=0, ç‚¼ä½“=1,...,ä»™ç­=10
      if (bigIdxCurrent >= 3) {
        const failChance = (bigIdxCurrent - 2) / 100; // 3â†’1%ï¼Œ4â†’2%ï¼Œ...
        if (Math.random() < failChance) {
          const lost = Math.floor(qi * 0.1);
          qi = Math.max(0, qi - lost);
          alert(`çªç ´å¤±è´¥ï¼çœŸæ°”éœ‡è¡ï¼ŒæŸå¤± ${lost} ç‚¹çœŸæ°”ã€‚å¯è°ƒæ•´å¿ƒå¢ƒåå†å°è¯•ã€‚`);
          updateUI();
          return;
        }
      }

      const oldName = getRealmNameFromStage(realmStage);
      const targetStage = realmStage + 1;

      realmStage = targetStage;
      applyStageBonus(realmStage);
      if (isBigRoundStage(realmStage)) {
        applyRealmBonus(realmStage);
      }
      // çœŸæ°”è¶³å¤Ÿçš„è¯ï¼Œç»§ç»­è‡ªåŠ¨è·¨å°é˜¶æ®µ
      checkBreakthrough();
      recalcDerivedStats();
      const newName = getRealmNameFromStage(realmStage);
      updateUI();
      alert(`ä½ ä»ã€Œ${oldName}ã€çªç ´åˆ°äº†ã€Œ${newName}ã€ï¼`);
    }

    /* ========== èƒ½åŠ›ç‚¹æ‰è½ï¼ˆå˜éš¾ + å—çµæ ¹ & æ°”è¿å½±å“ï¼‰ ========== */

    function rollAbilityPoint(source) {
      // æ¯”ä¹‹å‰éš¾åº¦é«˜ï¼šè‡ªåŠ¨ 0.4%ï¼Œç‚¹å‡» 1.8% åŸºç¡€
      const base = (source === 'auto') ? 0.004 : 0.018;
      const meta = getLingRootTierMeta();
      const lingMult = meta.abilityMult;
      const luckDiff = stats.luck - baseStats.luck;
      const luckMult = 1 + luckDiff * 0.03;
      let chance = base * lingMult * luckMult;
      if (chance > 0.8) chance = 0.8;
      if (Math.random() < chance) {
        abilityPoints++;
      }
    }

    /* ========== æ¸¸å†å±æ€§ï¼ˆå†ç»ƒç»™å¾®å¼±å¢ä¼¤ï¼‰ ========== */

    function getPlayerBattleStats() {
      // æ¯ç‚¹å†ç»ƒ +0.2% ä¼¤å®³ï¼Œä¸Šé™ +50%
      const expBuff = 1 + Math.min(experience * 0.002, 0.5);
      const maxHp = 90 + stats.physique * 9 + stats.root * 6;
      const mpMax = 50 + stats.spirit * 5;
      const atk = (10 + stats.power * 2) * expBuff;
      let dodge = 0.05 + stats.agility * 0.006;
      if (dodge > 0.45) dodge = 0.45;
      const spd = 100 + stats.agility * 2;

      return {
        maxHp: Math.floor(maxHp),
        hp: Math.floor(maxHp),
        mpMax: Math.floor(mpMax),
        mp: Math.floor(mpMax),
        atk: Math.floor(atk),
        dodge,
        spd,
        phys: stats.physique,
        root: stats.root
      };
    }

    function updateBattleStatsUI() {
      if (!playerBattleStatsDiv) return;
      if (!gameStarted) {
        playerBattleStatsDiv.textContent = 'å°šæœªè¸å…¥ä¿®è¡Œï¼Œå±æ€§æœªçŸ¥ã€‚';
        return;
      }
      const base = getPlayerBattleStats();
      playerBattleStatsDiv.textContent =
        `ä½ çš„å±æ€§ï¼šç”Ÿå‘½ ${base.maxHp} Â· æ”»å‡» ${base.atk} Â· è“é‡ ${base.mpMax} Â· ` +
        `é—ªé¿ ${(base.dodge * 100).toFixed(1)}% Â· é€Ÿåº¦ ${base.spd}`;
    }

    // çµæ ¹æš‚ä¸å½±å“æˆ˜æ–—æ•°å€¼ï¼ˆé¢„ç•™ï¼‰
    function getLingRootBattleEffects() {
      return {
        atkMul: 1,
        hpMul: 1,
        speedMul: 1,
        dodgeBonus: 0,
        damageTakenMul: 1,
        enemySpeedMul: 1,
        lifeSteal: 0,
        regenPerTurn: 0,
        critChance: 0,
        critMul: 1.5,
        extraTurnChance: 0,
        sleepChance: 0,
        heartRage: false
      };
    }

    /* ========== ä¼¤å®³å…¬å¼ï¼ˆç•¥æé«˜ä¼¤å®³ï¼Œç¼©çŸ­æ¸¸å†æˆ˜æ–—ï¼‰ ========== */

    function calcDamage(attackerAtk, defenderPhysique, defenderRoot) {
      const defScore = defenderPhysique * 0.6 + defenderRoot * 0.4;
      let mitigate = 1 / (1 + defScore * 0.018);
      if (mitigate < 0.35) mitigate = 0.35;
      if (mitigate > 1) mitigate = 1;
      const variance = 0.9 + Math.random() * 0.2;
      const raw = attackerAtk * variance;
      return Math.max(1, Math.floor(raw * mitigate));
    }

    /* ========== åœ°å›¾ç›¸å…³ ========= */

    function initMaps() {
      mapSelect.innerHTML = '';
      MAPS.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.name;
        mapSelect.appendChild(opt);
      });
      mapSelect.value = currentMapId;
    }

    function getCurrentMap() {
      return MAPS.find(m => m.id === currentMapId) || MAPS[0];
    }

    /* ========== æ•Œäººç”Ÿæˆ ========= */

    function generateRandomEnemy(targetStage) {
      const enemyStage = (typeof targetStage === 'number') ? targetStage : realmStage;
      const stageDiff = enemyStage - realmStage;
      const stageFactor = Math.max(0.4, 1 + stageDiff * 0.3);

      const basePower = Math.max(1, stats.power * stageFactor);
      const basePhys  = Math.max(1, stats.physique * stageFactor);
      const baseRoot  = Math.max(1, stats.root * stageFactor);
      const baseAgi   = Math.max(1, stats.agility * stageFactor);

      function randAround(v) {
        const factor = 1 + (Math.random() * 2 - 1) * 0.25;
        return Math.max(1, Math.round(v * factor));
      }

      const ePower = randAround(basePower);
      const ePhys  = randAround(basePhys);
      const eRoot  = randAround(baseRoot);
      const eAgi   = randAround(baseAgi);

      const maxHp = 80 + ePhys * 9 + eRoot * 6;
      const atk   = 9 + ePower * 2;
      let dodge   = 0.04 + eAgi * 0.005;
      if (dodge > 0.35) dodge = 0.35;
      const spd   = 100 + eAgi * 2;

      const realmName = getRealmNameFromStage(enemyStage);
      const namePool = ['æ¸¸è¡ä¿®å£«', 'è¯•ç‚¼å¹»å½±', 'æµæµªæ•£ä¿®', 'åŒé—¨å‰‘ä¿®', 'å¤é˜µæ®‹å½±'];
      const n = namePool[Math.floor(Math.random() * namePool.length)];

      return {
        name: `${realmName}Â·${n}`,
        maxHp: Math.floor(maxHp),
        hp: Math.floor(maxHp),
        atk: Math.floor(atk),
        dodge,
        spd,
        physique: ePhys,
        root: eRoot
      };
    }

    /* ========== å­˜æ¡£ç³»ç»Ÿ ========== */

    function saveGame() {
      const data = {
        qi,
        baseQiPerSecond,
        baseQiPerClick,
        realmQpsBonus,
        caveCount,
        caveQuality,
        pillLevel,
        pillQuality,
        realmStage,
        stats,
        abilityPoints,
        spiritStones,
        experience,
        playerName,
        lingRootIds: lingRoots.map(r => r.id),
        currentMapId,
        autoBattle,
        godTitleUnlocked,
        immortalTitle,
        immortalTitleUnlocked
      };
      try {
        localStorage.setItem(SAVE_KEY, JSON.stringify(data));
      } catch (e) {
        console.error('å­˜æ¡£å¤±è´¥ï¼š', e);
      }
    }

    function loadGame() {
      const raw = localStorage.getItem(SAVE_KEY);
      if (!raw) return;
      try {
        const data = JSON.parse(raw);
        if (typeof data.qi === 'number') qi = data.qi;
        baseQiPerSecond =
          typeof data.baseQiPerSecond === 'number' ? data.baseQiPerSecond : 0.1;
        baseQiPerClick =
          typeof data.baseQiPerClick === 'number' ? data.baseQiPerClick : 1.0;
        realmQpsBonus =
          typeof data.realmQpsBonus === 'number' ? data.realmQpsBonus : 0;

        caveCount =
          typeof data.caveCount === 'number' ? data.caveCount : 0;
        caveQuality =
          typeof data.caveQuality === 'number' ? data.caveQuality : 1;
        pillLevel =
          typeof data.pillLevel === 'number' ? data.pillLevel : 1;
        pillQuality =
          typeof data.pillQuality === 'number' ? data.pillQuality : 1;

        realmStage = (typeof data.realmStage === 'number') ? data.realmStage : 0;

        if (data.stats && typeof data.stats.power === 'number') {
          stats = { ...baseStats, ...data.stats };
        } else {
          stats = { ...baseStats };
        }

        abilityPoints = (typeof data.abilityPoints === 'number') ? data.abilityPoints : 0;
        spiritStones  = (typeof data.spiritStones === 'number') ? data.spiritStones : 0;
        experience    = (typeof data.experience === 'number') ? data.experience : 0;

        if (typeof data.playerName === 'string') playerName = data.playerName;

        if (Array.isArray(data.lingRootIds)) {
          lingRoots = data.lingRootIds
            .map(id => LING_ROOTS.find(r => r.id === id))
            .filter(Boolean);
        } else {
          lingRoots = [];
        }

        if (typeof data.currentMapId === 'string') {
          currentMapId = data.currentMapId;
        }

        autoBattle = !!data.autoBattle;
        godTitleUnlocked = !!data.godTitleUnlocked;
        immortalTitle = typeof data.immortalTitle === 'string' ? data.immortalTitle : '';
        immortalTitleUnlocked = !!data.immortalTitleUnlocked;
      } catch (e) {
        console.error('è¯»å–å­˜æ¡£å¤±è´¥ï¼š', e);
      }
      recalcDerivedStats();
    }

    function resetGame() {
      qi = 0;
      baseQiPerSecond = 0.1;
      baseQiPerClick = 1.0;
      realmQpsBonus = 0;
      recalcDerivedStats();

      caveCount = 0;
      caveQuality = 1;
      pillLevel = 1;
      pillQuality = 1;
      realmStage = 0;
      stats = { ...baseStats };
      abilityPoints = 0;
      spiritStones = 0;
      experience = 0;
      playerName = '';
      lingRoots = [];
      currentBattle = null;
      currentMapId = 'map_0';
      gameStarted = false;
      autoBattle = false;
      godTitleUnlocked = false;
      immortalTitle = '';
      immortalTitleUnlocked = false;
      localStorage.removeItem(SAVE_KEY);
      playerNameInput.value = '';
      battleLogDiv.innerHTML = '';
      battleResultDiv.textContent = '';
      startScreen.style.display = 'flex';
      autoBattleToggle.checked = false;
    }

    /* ========== UI åˆ‡æ¢ & æ›´æ–° ========== */

    function switchPage(page) {
      currentPage = page;
      pageCultivation.style.display = (page === 'cultivation') ? 'block' : 'none';
      pageBattle.style.display      = (page === 'battle')      ? 'block' : 'none';
      pageShop.style.display        = (page === 'shop')        ? 'block' : 'none';

      navItems.forEach(item => {
        item.classList.toggle('active', item.dataset.page === page);
      });
    }

    function updateUI() {
      const meta = getLingRootTierMeta();
      const effectiveQps = qiPerSecond * meta.qiMult;
      const effectiveQpc = qiPerClick * meta.qiMult;

      qiSpan.textContent  = qi.toFixed(1);
      qpsSpan.textContent = effectiveQps.toFixed(1);
      qpcSpan.textContent = effectiveQpc.toFixed(1);

      realmSpan.textContent = getRealmNameFromStage(realmStage);

      expMainSpan.textContent = experience;
      const expReq = getCurrentExpRequirementForBreak(realmStage, experience);
      expReqSpan.textContent = expReq > 0 ? expReq : 'â€”';

      const dmgBuffPercent = Math.min(experience * 0.2, 50);
      experienceSpan.textContent     = experience;
      experienceBuffSpan.textContent = dmgBuffPercent.toFixed(1);

      statPowerSpan.textContent    = stats.power;
      statPhysiqueSpan.textContent = stats.physique;
      statAgilitySpan.textContent  = stats.agility;
      statSpiritSpan.textContent   = stats.spirit;
      statRootSpan.textContent     = stats.root;
      statLuckSpan.textContent     = stats.luck;

      abilityPointsSpan.textContent    = abilityPoints;
      spiritStonesSpan.textContent     = spiritStones;
      shopSpiritStonesSpan.textContent = spiritStones;

      // å¸‚é›†ï¼šæ´åºœ
      const caveBuyCost = getCaveBuyCost();
      const caveUpCost  = getCaveUpgradeCost();
      caveCostSpan.textContent = caveBuyCost;
      caveCountSpan.textContent = caveCount;
      caveQualitySpan.textContent = getCaveQualityName();
      caveUpgradeCostSpan.textContent = caveUpCost;
      caveQpsSpan.textContent = getCaveQps().toFixed(2);

      // å¸‚é›†ï¼šä¸¹è¯
      const pillBuyCost = getPillBuyCost();
      const pillUpCost  = getPillUpgradeCost();
      pillCostSpan.textContent = pillBuyCost;
      pillLevelSpan.textContent = pillLevel;
      pillQualitySpan.textContent = getPillQualityName();
      pillUpgradeCostSpan.textContent = pillUpCost;

      // æŒ‰é’®å¯ç”¨æ€§
      plusButtons.forEach(btn => {
        btn.disabled = abilityPoints <= 0 || !gameStarted;
      });

      buyCaveBtn.disabled =
        !gameStarted || spiritStones < caveBuyCost;
      upgradeCaveBtn.disabled =
        !gameStarted || caveQuality >= MAX_CAVE_QUALITY || spiritStones < caveUpCost;

      buyPillBtn.disabled =
        !gameStarted || spiritStones < pillBuyCost;
      upgradePillBtn.disabled =
        !gameStarted || pillQuality >= MAX_PILL_QUALITY || spiritStones < pillUpCost;

      breakthroughBtn.disabled = !canManualBreakthrough();

      // æ˜¾ç¤ºé“å· + ç¥Â· + ä»™å·
      let displayName = playerName || 'æœªå‘½å';
      if (godTitleUnlocked) displayName = 'ç¥Â·' + displayName;
      if (immortalTitle) displayName = immortalTitle + 'Â·' + displayName;
      playerNameSpan.textContent = displayName;

      autoBattleToggle.checked = autoBattle;

      updateLingRootUI();
      updateBattleStatsUI();
    }

    /* ========== æ¸¸å†æ—¥å¿— & ç»“ç®— ========= */

    function appendBattleLog(msg) {
      const line = document.createElement('div');
      line.textContent = msg;
      battleLogDiv.appendChild(line);
      battleLogDiv.scrollTop = battleLogDiv.scrollHeight;
    }

    function handleRandomEncounter(outcome, battleData) {
      const meta = getLingRootTierMeta();
      const baseChance = 0.25;
      let chance = baseChance * meta.eventMult;
      if (chance > 0.9) chance = 0.9;

      let triggered = false;
      let text = '';
      let extraQi = 0;
      let extraStones = 0;
      let extraAbility = 0;
      let breakthrough = false;

      if (Math.random() >= chance) {
        text = 'è¿™æ¬¡æ¸¸å†é£å¹³æµªé™ï¼Œæœªè§¦å‘æ˜æ˜¾å¥‡é‡ã€‚ ' + getRandomEventText();
        return { triggered, text, extraQi, extraStones, extraAbility, breakthrough };
      }

      triggered = true;

      const options = ['stoneBurst', 'qiSurge', 'realmInsight', 'bigRealmFreeBreak', 'caveDiscover'];
      let type = options[Math.floor(Math.random() * options.length)];

      const isBigRound = isBigRoundStage(realmStage)
        && realmStage < REALM_NAMES.length - 1;

      if (!isBigRound && type === 'bigRealmFreeBreak') {
        type = 'qiSurge';
      }

      if (type === 'stoneBurst') {
        const idx = Math.max(0, getBigRealmIndex(realmStage));
        extraStones = 1 + Math.floor(Math.random() * (2 + idx));
        spiritStones += extraStones;
        text = `å¥‡é‡ï¼šä½ åœ¨å½’é€”ä¸­æ„å¤–å‘ç°ä¸€å°å †çµçŸ³ï¼Œé¢å¤–è·å¾— ${extraStones} æšçµçŸ³ã€‚`;
      } else if (type === 'qiSurge') {
        const extraQiBase = 10 + qiPerSecond * 20;
        extraQi = Math.floor(extraQiBase);
        gainQi(extraQi, 'event');
        text = `å¥‡é‡ï¼šä¸ç ´ä¸ç«‹ï¼Œä½ åœ¨å›æƒ³è¿™æ¬¡æ¸¸å†æ—¶æ°”æœºé¼“è¡ï¼Œä¸€å£æ°”æå‡äº† ${extraQi} ç‚¹çœŸæ°”ã€‚`;
      } else if (type === 'realmInsight') {
        const nextStage = realmStage + 1;
        if (nextStage < realmThresholds.length && qi >= realmThresholds[nextStage]) {
          // ç›´æ¥å°çªç ´
          realmStage++;
          applyStageBonus(realmStage);
          if (isBigRoundStage(realmStage)) {
            applyRealmBonus(realmStage);
          }
          checkBreakthrough();
          breakthrough = true;
          text = `å¥‡é‡ï¼šæ­¤æ¬¡æ¸¸å†è®©ä½ æ„Ÿæ‚Ÿè®¸å¤šï¼Œå¢ƒç•Œæ‚„ç„¶çªç ´è‡³ã€Œ${getRealmNameFromStage(realmStage)}ã€ã€‚`;
        } else {
          extraAbility = 1;
          abilityPoints += 1;
          text = 'å¥‡é‡ï¼šä½ å¯¹æˆ˜æ–—ç»†èŠ‚å›å‘³è‰¯ä¹…ï¼Œå¿ƒæœ‰æ‰€æ‚Ÿï¼Œé¢å¤–è·å¾— 1 ç‚¹èƒ½åŠ›ç‚¹ã€‚';
        }
      } else if (type === 'bigRealmFreeBreak') {
        const nextStage = realmStage + 1;
        if (isBigRound && nextStage < realmThresholds.length && qi >= realmThresholds[nextStage]) {
          realmStage++;
          applyStageBonus(realmStage);
          if (isBigRoundStage(realmStage)) {
            applyRealmBonus(realmStage);
          }
          checkBreakthrough();
          breakthrough = true;
          text = `å¥‡é‡ï¼šä½ æœ¬å°±å¤„äºå¤§åœ†æ»¡è¾¹ç¼˜ï¼Œåœ¨è¿™æ¬¡æ¸¸å†èƒœåˆ©åï¼Œæ— éœ€é¢å¤–å†ç»ƒä¾¿ç›´æ¥çªç ´è‡³ã€Œ${getRealmNameFromStage(realmStage)}ã€ã€‚`;
        } else {
          text = 'å¥‡é‡ï¼šä½ éšçº¦æ„Ÿåˆ°ç“¶é¢ˆæ¾åŠ¨ï¼Œå´ä»å·®ä¸€æ­¥ç«å€™ã€‚';
        }
      } else if (type === 'caveDiscover') {
        if (caveQuality < MAX_CAVE_QUALITY) {
          caveQuality++;
          recalcDerivedStats();
          text = `å¥‡é‡ï¼šä½ åœ¨å±±é—´å‘ç°ä¸€å¤„çµæ°”æ„ˆå‘æµ‘åšçš„æ´çªŸï¼Œå°†åŸæœ‰æ´åºœæ®æ­¤æ”¹é€ ï¼Œæ´åºœå“è´¨æå‡ä¸ºã€Œ${getCaveQualityName()}ã€ï¼Œè‡ªåŠ¨ä¿®ç‚¼é€Ÿåº¦å¤§å¹…æå‡ã€‚`;
        } else {
          extraStones = 2 + Math.floor(Math.random() * 3);
          spiritStones += extraStones;
          text = `å¥‡é‡ï¼šä½ æ‰“ç®—æ”¹é€ æ´åºœï¼Œå´å‘ç°å·²éš¾ä»¥æ›´è¿›ä¸€æ­¥ï¼Œåªå¾—æŠŠå¿ƒæ€è½¬ä¸ºæœåˆ®é™„è¿‘èµ„æºï¼Œé¢å¤–è·å¾— ${extraStones} æšçµçŸ³ã€‚`;
        }
      }

      text += ' ' + getRandomEventText();
      return { triggered, text, extraQi, extraStones, extraAbility, breakthrough };
    }

    function showBattleResultOverlay(outcome, battleData, rewards, eventInfo) {
      resultTitle.textContent =
        outcome === 'win' ? 'æ¸¸å†èƒœåˆ©'
        : outcome === 'lose' ? 'æ¸¸å†å—æŒ«'
        : 'ä¸åˆ†èƒœè´Ÿ';

      const enemyName = battleData.enemy.name;
      const summaryLines = [];
      if (outcome === 'win') {
        summaryLines.push(`ä½ æˆåŠŸå‡»è´¥äº†ã€Œ${enemyName}ã€ã€‚`);
      } else if (outcome === 'lose') {
        summaryLines.push(`ä½ è¢«ã€Œ${enemyName}ã€å‡»é€€ï¼Œåªå¾—æš‚ä¸”æ’¤ç¦»ã€‚`);
      } else {
        summaryLines.push(`ä½ ä¸ã€Œ${enemyName}ã€é–æˆ˜å¤šå›åˆï¼Œæœ€ç»ˆæš‚ä¸”ç½¢æ‰‹ã€‚`);
      }
      summaryLines.push(`æœ¬æ¬¡æ¸¸å†å…±è¿›è¡Œäº† ${battleData.turn - 1} ä¸ªå›åˆã€‚`);
      resultSummary.textContent = summaryLines.join(' ');

      const dropsText = [
        rewards.qiReward > 0     ? `çœŸæ°”ï¼š+${rewards.qiReward}` : null,
        rewards.expGain > 0      ? `å†ç»ƒå€¼ï¼š+${rewards.expGain}ï¼ˆæ€»å†ç»ƒï¼š${experience}ï¼‰` : `å†ç»ƒå€¼ï¼šæ— å¢é•¿`,
        rewards.abilityGain > 0  ? `èƒ½åŠ›ç‚¹ï¼š+${rewards.abilityGain}ï¼ˆå¯ç”¨ï¼š${abilityPoints}ï¼‰` : null,
        rewards.stoneReward > 0  ? `çµçŸ³ï¼š+${rewards.stoneReward}ï¼ˆæ€»è®¡ï¼š${spiritStones}ï¼‰` : null
      ].filter(Boolean).join(' Â· ');
      resultDrops.textContent = dropsText || 'æœ¬æ¬¡æœªè·å¾—æ˜¾è‘—æˆ˜åˆ©å“ã€‚';

      let extra = '';
      if (isBigRoundStage(realmStage)) {
        const req = getCurrentExpRequirementForBreak(realmStage, experience);
        extra = `å½“å‰å¢ƒç•Œï¼š${getRealmNameFromStage(realmStage)}ï¼›çªç ´åˆ°ä¸‹ä¸€å¤§å¢ƒç•Œæ‰€éœ€å†ç»ƒå€¼çº¦ä¸º ${req}ã€‚`;
      } else {
        extra = `å½“å‰å¢ƒç•Œï¼š${getRealmNameFromStage(realmStage)}ã€‚`;
      }
      resultExtra.textContent = extra;

      randomEventDiv.textContent = eventInfo.text || 'æœ¬æ¬¡æœªè§¦å‘å¥‡é‡ã€‚';

      battleResultOverlay.style.display = 'flex';
    }

    function endBattle(outcome) {
      if (!currentBattle) return;
      clearInterval(battleTimerId);
      battleTimerId = null;
      startBattleBtn.disabled = false;

      const battleData = currentBattle;
      currentBattle = null;

      const map = battleData.map;
      const rewardMult = map.rewardMult;

      let qiReward = 0;
      let stoneReward = 0;

      const idx = Math.max(0, getBigRealmIndex(realmStage));

      if (outcome === 'win') {
        const baseQi = 6 + idx * 3;
        qiReward = Math.round((baseQi + Math.random() * (5 + idx * 3)) * rewardMult);
        stoneReward = (Math.random() < 0.7)
          ? 1 + Math.floor(Math.random() * (1 + idx + 1))
          : 0;
      } else if (outcome === 'lose') {
        qiReward = Math.round((2 + idx) * rewardMult);
      } else {
        qiReward = Math.round((3 + idx) * rewardMult);
      }

      let expGain = 0;
      if (outcome === 'win') {
        expGain = Math.max(1, Math.round((3 + idx * 2) * rewardMult));
      } else if (outcome === 'lose') {
        expGain = Math.max(1, Math.round((1 + idx) * rewardMult));
      } else {
        expGain = Math.max(1, Math.round((2 + idx) * rewardMult));
      }
      experience += expGain;

      const abilityBefore = battleData.abilityBefore;
      const expBefore = battleData.expBefore;

      if (qiReward > 0) gainQi(qiReward, 'battle');
      if (stoneReward > 0) spiritStones += stoneReward;

      const eventInfo = handleRandomEncounter(outcome, battleData);

      const abilityGain = abilityPoints - abilityBefore;
      const totalExpGain = experience - expBefore;
      const totalStoneReward = stoneReward + (eventInfo.extraStones || 0);

      updateUI();

      const shouldShowOverlay = !(autoBattle && currentPage !== 'battle');
      if (shouldShowOverlay) {
        showBattleResultOverlay(outcome, battleData, {
          qiReward,
          stoneReward: totalStoneReward,
          expGain: totalExpGain,
          abilityGain
        }, eventInfo);
      } else {
        // è‡ªåŠ¨ç»“ç®—æ¨¡å¼ï¼šä¸å¼¹å‡ºç»“ç®—çª—å£ï¼Œåªåœ¨æ¸¸å†é¡µç®€å•æç¤º
        battleResultDiv.textContent =
          `ä¸€åœºæ¸¸å†å·²ç»“æŸï¼ˆ${outcome === 'win' ? 'èƒœåˆ©' : outcome === 'lose' ? 'å—æŒ«' : 'å¹³å±€'}ï¼‰ï¼Œå¥–åŠ±å·²è‡ªåŠ¨ç»“ç®—ã€‚`;
        saveGame();
      }
    }

    function runBattleTurn() {
      if (!currentBattle) {
        clearInterval(battleTimerId);
        battleTimerId = null;
        return;
      }
      const b = currentBattle;
      const eff = b.effects;

      if (b.player.hp <= 0 || b.enemy.hp <= 0 || b.turn > MAX_TURNS) {
        let outcome = 'draw';
        if (b.player.hp > 0 && b.enemy.hp <= 0) outcome = 'win';
        else if (b.enemy.hp > 0 && b.player.hp <= 0) outcome = 'lose';
        endBattle(outcome);
        return;
      }

      if (b.currentActor === 'player') {
        if (eff.regenPerTurn > 0) {
          const oldHp = b.player.hp;
          b.player.hp = Math.min(b.player.maxHp, b.player.hp + eff.regenPerTurn);
          if (b.player.hp > oldHp) {
            appendBattleLog(`å›åˆ ${b.turn}ï¼šä½ çš„ä½“é­„æ¢å¤äº† ${b.player.hp - oldHp} ç‚¹ç”Ÿå‘½ã€‚`);
          }
        }

        const effectiveAtk = b.player.atk;
        let dmg = calcDamage(effectiveAtk, b.enemy.physique, b.enemy.root);

        let crit = false;
        if (eff.critChance > 0 && Math.random() < eff.critChance) {
          crit = true;
          dmg = Math.floor(dmg * eff.critMul);
        }

        const dodgeRoll = Math.random();
        if (dodgeRoll < b.enemy.dodge) {
          appendBattleLog(`å›åˆ ${b.turn}ï¼šä½ å‡ºæ‰‹æ”»å‡»ï¼Œä½†ã€Œ${b.enemy.name}ã€é—ªé¿äº†è¿™ä¸€å‡»ã€‚`);
        } else {
          b.enemy.hp = Math.max(0, b.enemy.hp - dmg);
          let text = `å›åˆ ${b.turn}ï¼šä½ æ”»å‡»ã€Œ${b.enemy.name}ã€ï¼Œé€ æˆ ${dmg} ç‚¹ä¼¤å®³ï¼ˆå¯¹æ–¹å‰©ä½™ ${b.enemy.hp}ï¼‰ã€‚`;
          if (crit) text += 'ã€æš´å‡»ã€‘';
          appendBattleLog(text);
        }

        let changeTurn = true;
        if (b.enemy.hp > 0 && eff.extraTurnChance > 0 && Math.random() < eff.extraTurnChance) {
          appendBattleLog('æ—¶é—´ä¼¼ä¹ä¸ºä½ åœæ»äº†ä¸€ç¬ï¼Œä½ æŠ“ä½ç©ºéš™å†æ¬¡å‡ºæ‰‹ï¼');
          changeTurn = false;
        }

        b.currentActor = changeTurn ? 'enemy' : 'player';
        b.turn++;
      } else {
        const dodgeRoll = Math.random();
        if (dodgeRoll < b.player.dodge) {
          appendBattleLog(`å›åˆ ${b.turn}ï¼šã€Œ${b.enemy.name}ã€æ”»å‡»ä½ ï¼Œä½†ä½ èº«å½¢ä¸€é—ªèº²äº†è¿‡å»ã€‚`);
        } else {
          let dmg = calcDamage(b.enemy.atk, b.player.physDef, b.player.rootDef);
          dmg = Math.floor(dmg * eff.damageTakenMul);
          if (dmg < 1) dmg = 1;
          b.player.hp = Math.max(0, b.player.hp - dmg);
          appendBattleLog(
            `å›åˆ ${b.turn}ï¼šã€Œ${b.enemy.name}ã€æ”»å‡»ä½ ï¼Œé€ æˆ ${dmg} ç‚¹ä¼¤å®³ï¼ˆä½ å‰©ä½™ ${b.player.hp}ï¼‰ã€‚`
          );
        }
        b.currentActor = 'player';
        b.turn++;
      }
    }

    function startBattle() {
      if (!gameStarted) {
        battleResultDiv.textContent = 'è¯·å…ˆè¸å…¥ä¿®ä»™å¹¶å®Œæˆå‘½åã€‚';
        return;
      }
      if (battleTimerId) return;

      const pBase = getPlayerBattleStats();
      const eff = getLingRootBattleEffects();
      const map = getCurrentMap();
      const enemyBase = generateRandomEnemy(map.enemyStage);

      const maxHp = Math.floor(pBase.maxHp * eff.hpMul);
      const atk   = Math.floor(pBase.atk * eff.atkMul);
      const dodge = Math.min(0.5, pBase.dodge + eff.dodgeBonus);
      const spd   = Math.floor(pBase.spd * eff.speedMul);

      const enemy = {
        name: enemyBase.name,
        maxHp: enemyBase.maxHp,
        hp: enemyBase.hp,
        atk: enemyBase.atk,
        dodge: enemyBase.dodge,
        spd: Math.floor(enemyBase.spd * eff.enemySpeedMul),
        physique: enemyBase.physique,
        root: enemyBase.root
      };

      currentBattle = {
        player: {
          hp: maxHp,
          maxHp,
          atk,
          dodge,
          spd,
          physDef: stats.physique,
          rootDef: stats.root
        },
        enemy,
        turn: 1,
        currentActor: null,
        effects: eff,
        map,
        abilityBefore: abilityPoints,
        expBefore: experience
      };

      battleLogDiv.innerHTML = '';
      battleResultDiv.textContent = '';

      appendBattleLog(`æ¸¸å†å¼€å§‹ï¼ä½ åœ¨ã€Œ${map.name}ã€ä¸ã€Œ${enemy.name}ã€å±•å¼€è¯•ç‚¼ã€‚`);
      if (currentBattle.player.spd >= currentBattle.enemy.spd) {
        currentBattle.currentActor = 'player';
        appendBattleLog('ä½ èº«æ³•æ›´å¿«ï¼Œç‡å…ˆå‡ºæ‰‹ã€‚');
      } else {
        currentBattle.currentActor = 'enemy';
        appendBattleLog(`ã€Œ${enemy.name}ã€å…ˆå‘åˆ¶äººï¼`);
      }

      startBattleBtn.disabled = true;
      battleTimerId = setInterval(runBattleTurn, BATTLE_TURN_DELAY);
    }

    /* ========== çœŸæ°”è·å– ========== */

    function gainQi(amount, source) {
      if (!gameStarted) return;
      const meta = getLingRootTierMeta();
      let finalAmount = amount;
      if (['auto','click','battle','event'].includes(source)) {
        finalAmount *= meta.qiMult;
      }

      const oldStage = realmStage;
      qi += finalAmount;
      rollAbilityPoint(source);
      checkBreakthrough();

      if (realmStage > oldStage && currentBattle) {
        appendBattleLog(`åœ¨æ¿€æˆ˜ä¸­ï¼Œä½ ä½“å†…çœŸæ°”æ²¸è…¾ï¼Œå¢ƒç•Œçªç ´è‡³ã€Œ${getRealmNameFromStage(realmStage)}ã€ï¼`);
      }
    }

    /* ========== äº¤äº’ç»‘å®š ========== */

    // åº•éƒ¨å¯¼èˆª
    navItems.forEach(item => {
      item.addEventListener('click', () => {
        const page = item.dataset.page;
        switchPage(page);
      });
    });

    // åœ°å›¾é€‰æ‹©
    mapSelect.addEventListener('change', () => {
      currentMapId = mapSelect.value;
      saveGame();
    });

    // è‡ªåŠ¨æˆ˜æ–—ç»“ç®—å¼€å…³
    autoBattleToggle.addEventListener('change', () => {
      autoBattle = autoBattleToggle.checked;
      saveGame();
    });

    // ä¿®ç‚¼æ“ä½œ
    cultivateBtn.addEventListener('click', () => {
      gainQi(qiPerClick, 'click');
      updateUI();
    });

    // å¸‚é›†ï¼šæ´åºœ
    buyCaveBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      const cost = getCaveBuyCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        caveCount += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    upgradeCaveBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      if (caveQuality >= MAX_CAVE_QUALITY) return;
      const cost = getCaveUpgradeCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        caveQuality += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    // å¸‚é›†ï¼šä¸¹è¯
    buyPillBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      const cost = getPillBuyCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        pillLevel += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    upgradePillBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      if (pillQuality >= MAX_PILL_QUALITY) return;
      const cost = getPillUpgradeCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        pillQuality += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    // èƒ½åŠ›ç‚¹åŠ ç‚¹
    plusButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        if (!gameStarted) return;
        const key = btn.dataset.stat;
        if (abilityPoints > 0 && stats[key] != null) {
          abilityPoints--;
          stats[key] += 1;
          updateUI();
        }
      });
    });

    saveBtn.addEventListener('click', () => {
      saveGame();
      saveBtn.textContent = 'å·²ä¿å­˜ âœ”';
      setTimeout(() => { saveBtn.textContent = 'æ‰‹åŠ¨ä¿å­˜'; }, 1000);
    });

    resetBtn.addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºå­˜æ¡£å¹¶ä»å‡¡äººå¢ƒç•Œé‡æ–°ä¿®ç‚¼å—ï¼Ÿ')) {
        resetGame();
        updateUI();
        switchPage('cultivation');
      }
    });

    startBattleBtn.addEventListener('click', () => {
      startBattle();
    });

    closeResultBtn.addEventListener('click', () => {
      battleResultOverlay.style.display = 'none';
      updateUI();
      saveGame();
    });

    breakthroughBtn.addEventListener('click', () => {
      doManualBreakthrough();
    });

    startGameBtn.addEventListener('click', () => {
      let name = playerNameInput.value.trim();
      if (!name) name = 'æ— åæ•£ä¿®';
      playerName = name;
      if (!lingRoots || lingRoots.length === 0) {
        lingRoots = generateLingRoots();
      }
      gameStarted = true;
      startScreen.style.display = 'none';
      saveGame();
      updateUI();
    });

    /* ========== æ”¾ç½®å¾ªç¯ & è‡ªåŠ¨å­˜æ¡£ ========== */

    setInterval(() => {
      if (!gameStarted) return;
      gainQi(qiPerSecond, 'auto');
      updateUI();
    }, 1000);

    setInterval(() => {
      if (!gameStarted) return;
      saveGame();
    }, 5000);

    /* ========== åˆå§‹åŒ– ========== */

    generateMaps();
    loadGame();
    initMaps();

    if (playerName) {
      gameStarted = true;
      startScreen.style.display = 'none';
    } else {
      gameStarted = false;
      startScreen.style.display = 'flex';
    }

    switchPage('cultivation');
    updateUI();
  </script>
</body>
</html>

