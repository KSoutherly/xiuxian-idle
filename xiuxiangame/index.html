<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
  <title>ä»™é€”æ”¾ç½® Demo</title>
  <style>
/* ====== é€šç”¨å¸ƒå±€ & èƒŒæ™¯ ====== */
body {
  font-family: "Microsoft YaHei", system-ui, -apple-system, BlinkMacSystemFont, sans-serif;
  background: radial-gradient(circle at top, #1b2340, #05060a);
  color: #f3f3f3;
  display: flex;
  justify-content: center;
  padding: 24px 12px;
}

.app-container {
  width: 100%;
  max-width: 520px;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
}

/* ====== é¡¶éƒ¨æ ‡é¢˜æ  ====== */
.top-bar {
  text-align: center;
  margin-bottom: 8px;
}

h1 {
  margin-bottom: 4px;
  letter-spacing: 2px;
  font-size: 24px;
}

.subtitle {
  font-size: 13px;
  color: #b6c1ff;
  margin-bottom: 4px;
}

.player-info {
  font-size: 13px;
  color: #d3d6ff;
}

/* ====== ä¸»ä½“åŒºåŸŸ ====== */
.main-area {
  flex: 1;
  display: flex;
  flex-direction: column;
  align-items: center;
  width: 100%;
}

/* çŠ¶æ€é¢æ¿ */
.stats {
  margin: 10px 0 10px;
  text-align: center;
  line-height: 1.6;
  padding: 12px 18px;
  border-radius: 12px;
  background: rgba(15, 20, 40, 0.9);
  box-shadow: 0 0 18px rgba(0, 0, 0, 0.45);
  border: 1px solid rgba(120, 150, 255, 0.4);
  width: 100%;
}

#realm {
  font-weight: bold;
  color: #ffd56b;
}

.stats-actions {
  margin-top: 6px;
  display: flex;
  justify-content: center;
  gap: 8px;
}

/* æŒ‰é’®æ ·å¼ */
button {
  padding: 10px 16px;
  margin: 6px 0;
  border: none;
  border-radius: 999px;
  cursor: pointer;
  font-size: 14px;
  background: linear-gradient(120deg, #3a8bff, #7a5cff);
  color: #fff;
  box-shadow: 0 4px 10px rgba(0, 0, 0, 0.45);
  transition: transform 0.08s ease, box-shadow 0.08s ease, opacity 0.2s ease;
}

button:hover:not(:disabled) {
  transform: translateY(-1px);
  box-shadow: 0 6px 18px rgba(0, 0, 0, 0.6);
}

button:active:not(:disabled) {
  transform: translateY(1px);
  box-shadow: 0 2px 8px rgba(0, 0, 0, 0.5);
}

button:disabled {
  opacity: 0.5;
  cursor: not-allowed;
}

.btn-main {
  font-size: 18px;
  padding: 12px 24px;
  margin: 12px 0 10px;
}

.btn-small {
  padding: 6px 10px;
  font-size: 12px;
  margin: 0;
}

/* é€šç”¨åŠŸèƒ½é¢æ¿å¡ç‰‡ */
.panel {
  background: rgba(12, 16, 32, 0.95);
  border-radius: 14px;
  padding: 16px;
  margin-top: 8px;
  width: 100%;
  box-shadow: 0 0 14px rgba(0, 0, 0, 0.5);
  border: 1px solid rgba(90, 120, 220, 0.7);
}

.panel h2 {
  margin-top: 0;
  font-size: 18px;
  color: #e9f0ff;
  display: flex;
  align-items: center;
  gap: 6px;
}

.panel h2::before {
  content: "âœ¦";
  font-size: 14px;
  color: #ffd56b;
}

.upgrade {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin: 6px 0;
}

.upgrade-info {
  font-size: 13px;
}

.hint {
  font-size: 12px;
  color: #9aa0c6;
  margin-top: 8px;
  line-height: 1.5;
}

/* å…­ç»´è¡¨æ ¼ */
.stats-grid {
  display: flex;
  flex-direction: column;
  gap: 4px;
  font-size: 13px;
}

.stat-row {
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.stat-right {
  display: flex;
  align-items: center;
  gap: 4px;
}

.btn-plus {
  padding: 2px 8px;
  font-size: 11px;
  margin: 0;
  border-radius: 999px;
  background: linear-gradient(120deg, #5ac8fa, #007aff);
}

/* çµæ ¹è¯´æ˜è¡¨ */
.ling-root-table {
  font-size: 13px;
  margin-top: 8px;
}

.ling-root-row {
  display: flex;
  justify-content: space-between;
  margin: 2px 0;
}

/* æ¸¸å†æ—¥å¿— */
#battleLog {
  margin-top: 8px;
  max-height: 220px;
  overflow-y: auto;
  font-size: 12px;
  line-height: 1.5;
  background: rgba(5, 8, 20, 0.85);
  padding: 8px 10px;
  border-radius: 10px;
  border: 1px solid rgba(120, 150, 255, 0.3);
}

/* åº•éƒ¨å¯¼èˆª */
.bottom-nav {
  margin-top: 16px;
  padding: 8px 10px;
  border-radius: 18px;
  background: rgba(10, 12, 24, 0.95);
  box-shadow: 0 -4px 12px rgba(0, 0, 0, 0.6);
  display: flex;
  justify-content: space-around;
  align-items: center;
}

.nav-item {
  display: flex;
  flex-direction: column;
  align-items: center;
  font-size: 11px;
  color: #9aa0c6;
}

.nav-item.active {
  color: #ffd56b;
}

.nav-icon {
  width: 40px;
  height: 40px;
  border-radius: 50%;
  background: radial-gradient(circle, #384173, #151728);
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 20px;
  margin-bottom: 4px;
}

/* å¼€å±€è¾“å…¥é“å·ç•Œé¢ */
.start-screen {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.82);
  display: flex;
  align-items: center;
  justify-content: center;
  z-index: 100;
}

.start-card {
  background: rgba(10, 12, 30, 0.98);
  border-radius: 16px;
  padding: 20px 18px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 0 24px rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(120, 150, 255, 0.8);
  text-align: center;
}

.start-card h2 {
  margin-top: 0;
  margin-bottom: 10px;
  font-size: 20px;
}

.start-card p {
  font-size: 13px;
  color: #c0c6ff;
  margin-bottom: 10px;
}

.start-card input {
  width: 80%; /* ç¼©çŸ­ä¸€ç‚¹è¾“å…¥æ¡† */
  padding: 8px 12px;
  border-radius: 999px;
  border: none;
  outline: none;
  margin: 8px 0 14px;
  font-size: 14px;
}

.start-card .tip {
  font-size: 12px;
  color: #8f94c9;
  margin-bottom: 10px;
}

/* æ¸¸å†ç»“ç®— & éšæœºäº‹ä»¶å¼¹å±‚ï¼ˆåªç”¨äºæ‰‹åŠ¨æˆ˜æ–—æ¨¡å¼ï¼‰ */
.overlay-screen {
  position: fixed;
  inset: 0;
  background: rgba(0, 0, 0, 0.78);
  display: none;
  align-items: center;
  justify-content: center;
  z-index: 110;
}

.result-card {
  background: rgba(10, 12, 30, 0.98);
  border-radius: 16px;
  padding: 18px 16px;
  width: 90%;
  max-width: 360px;
  box-shadow: 0 0 24px rgba(0, 0, 0, 0.8);
  border: 1px solid rgba(200, 180, 120, 0.8);
  text-align: left;
}

.result-card h2 {
  margin: 0 0 8px;
  font-size: 18px;
}

.result-summary {
  font-size: 13px;
  color: #f5f5f5;
  margin-bottom: 8px;
}

.result-drops {
  font-size: 13px;
  color: #ffd56b;
  margin-bottom: 8px;
}

.result-extra {
  font-size: 12px;
  color: #d6dcff;
  margin-bottom: 8px;
}

.result-random {
  font-size: 12px;
  color: #c0c6ff;
  margin-bottom: 10px;
}

/* ====== åŠŸæ³• / å®—é—¨ / æŠ€èƒ½å±•ç¤º ====== */
.skill-item {
  border-radius: 8px;
  padding: 6px 8px;
  margin-bottom: 6px;
  background: rgba(20, 24, 48, 0.9);
  display: flex;
  justify-content: space-between;
  align-items: flex-start;
  gap: 8px;
  font-size: 12px;
}

.skill-left {
  flex: 1;
}

.skill-name {
  font-size: 13px;
  font-weight: bold;
  margin-bottom: 2px;
}

/* ç¨€æœ‰åº¦é¢œè‰²ï¼šå‡¡å“ã€ç½•è§ã€ç¨€æœ‰ã€çå“ã€ç»å“ã€ä»™æ³• */
.skill-rarity-common { color: #f5f5f5; }
.skill-rarity-uncommon { color: #6cff8f; }
.skill-rarity-rare { color: #4ea1ff; }
.skill-rarity-epic { color: #c47dff; }
.skill-rarity-legendary { color: #ffd86b; }
.skill-rarity-mythic { color: #ff6666; }

/* å¤§å±å¹•ï¼ˆå¯é€‰ï¼‰ */
@media (min-width: 900px) {
  .app-container {
    max-width: 620px;
  }
}
  
/* ====== å¼€å±€çµæ ¹æŠ½å–è½¬ç›˜ & é«˜å…‰é¢œè‰² ====== */

.root-draw-panel {
  margin: 32px auto 12px;
  max-width: 420px;
}

.root-draw-subtitle {
  font-size: 13px;
  color: #c0c6ff;
  margin-bottom: 4px;
}

.root-wheel-wrapper {
  display: flex;
  justify-content: center;
  margin: 10px 0;
}

.root-wheel {
  width: 120px;
  height: 120px;
  border-radius: 50%;
  border: 2px solid rgba(255, 255, 255, 0.25);
  box-shadow: 0 0 12px rgba(0, 0, 0, 0.7);
  display: flex;
  align-items: center;
  justify-content: center;
  text-align: center;
  font-size: 13px;
}

.root-wheel-name {
  padding: 4px 6px;
}

.root-result {
  font-size: 13px;
  margin-top: 6px;
}

.root-result-tier {
  margin-top: 2px;
}

.root-result-desc {
  margin-top: 4px;
  color: #c0c6ff;
}

.root-draw-controls {
  display: flex;
  gap: 8px;
  margin-top: 10px;
}

.root-draw-controls button {
  flex: 1;
}

.root-confirm-row {
  margin-top: 10px;
  text-align: center;
}

.root-warning {
  margin-top: 8px;
  font-size: 12px;
  color: #ffdd9b;
}

.switch-label {
  display: inline-flex;
  align-items: center;
  gap: 6px;
  font-size: 12px;
}

.spirit-root-tag {
  display: inline-flex;
  align-items: center;
  padding: 1px 8px;
  border-radius: 999px;
  background: rgba(10, 16, 40, 0.9);
  font-weight: 600;
  font-size: 13px;
}

/* çµæ ¹é«˜å…‰é¢œè‰²ï¼ˆä»…ç”¨äºæ–‡å­—ï¼‰ */
.root-color-metal   { color: #ffd94a; text-shadow: 0 0 6px rgba(255, 217, 74, 0.8); }
.root-color-wood    { color: #4cd964; text-shadow: 0 0 6px rgba(76, 217, 100, 0.8); }
.root-color-water   { color: #5ac8fa; text-shadow: 0 0 6px rgba(90, 200, 250, 0.8); }
.root-color-fire    { color: #ff3b30; text-shadow: 0 0 6px rgba(255, 59, 48, 0.8); }
.root-color-earth   { color: #d08b4c; text-shadow: 0 0 6px rgba(208, 139, 76, 0.8); }

.root-color-ice     { color: #a0e9ff; text-shadow: 0 0 6px rgba(160, 233, 255, 0.8); }
.root-color-thunder { color: #b076ff; text-shadow: 0 0 6px rgba(176, 118, 255, 0.8); }
.root-color-heart   { color: #ff8ac9; text-shadow: 0 0 6px rgba(255, 138, 201, 0.8); }
.root-color-spirit  { color: #c6ffb5; text-shadow: 0 0 6px rgba(198, 255, 181, 0.8); }
.root-color-dream   { color: #ffd1f2; text-shadow: 0 0 6px rgba(255, 209, 242, 0.8); }

.root-color-dark    { color: #b00020; text-shadow: 0 0 6px rgba(176, 0, 32, 0.8); }
.root-color-light   { color: #fff5d9; text-shadow: 0 0 6px rgba(255, 245, 217, 0.9); }
.root-color-realm   { color: #c4e0ff; text-shadow: 0 0 6px rgba(196, 224, 255, 0.9); }
.root-color-holy    { color: #f3e2b5; text-shadow: 0 0 6px rgba(243, 226, 181, 0.9); }

/* ç©ºé—´ / æ—¶é—´ï¼šä¸€åŠé»‘ä¸€åŠç™½çš„æ–‡å­— */
.root-color-space {
  background-image: linear-gradient(90deg, #000 0%, #000 50%, #fff 50%, #fff 100%);
  -webkit-background-clip: text;
  color: transparent;
}

.root-color-time {
  background-image: linear-gradient(90deg, #fff 0%, #fff 50%, #000 50%, #000 100%);
  -webkit-background-clip: text;
  color: transparent;
}

/* å› æœï¼šé»‘ç™½é—ªçƒ */
.root-color-cause {
  animation: root-cause-blink 1.2s infinite;
}

@keyframes root-cause-blink {
  0%, 45% {
    color: #000;
    text-shadow: 0 0 5px rgba(0, 0, 0, 0.8);
  }
  55%, 100% {
    color: #fff;
    text-shadow: 0 0 5px rgba(255, 255, 255, 0.9);
  }
}

/* ===== è‡ªå®šä¹‰åº•éƒ¨ä¸»èœå•å›¾ç‰‡æ¡ ===== */
.app-container {
  padding-bottom: 130px;
}

.bottom-nav {
  position: fixed;
  left: 50%;
  transform: translateX(-50%);
  bottom: 16px;
  width: 100%;
  max-width: 520px;
  height: 96px;
  margin-top: 0;
  padding: 0;
  border-radius: 0;
  background: url('main_menu_bar_cropped.png') no-repeat center center;
  background-size: 100% 100%;
  background-position: center bottom;
  box-shadow: none;
}

.bottom-nav .nav-item {
  flex: 1;
  height: 100%;
  display: flex;
  flex-direction: column;
  justify-content: flex-end;
  align-items: center;
  padding-bottom: 12px;
  background: transparent;
}

.bottom-nav .nav-icon,
.bottom-nav .nav-label {
  font-size: 0;
  line-height: 0;
}

.bottom-nav .nav-icon {
  display: none;
}

.bottom-nav .nav-label {
  display: none;
}


</style>
</head>
<body>

  <!-- å¼€å±€å‘½å -->
  <div id="startScreen" class="start-screen">
    <div class="start-card">
      <h2>è¸å…¥ä¿®ä»™ä¹‹è·¯</h2>
      <p>è¯·ä¸ºè‡ªå·±å–ä¸€ä¸ªé“å·ï¼š</p>
      <input id="playerNameInput" type="text" placeholder="ä¾‹å¦‚ï¼šæ— åæ•£ä¿® / é’å±±æ•£äºº" />
      <div class="tip">å¼€å§‹ä¿®ç‚¼åï¼Œå°†éšæœºè§‰é†’ä¸€ç»„çµæ ¹ï¼ˆå¯èƒ½ä¸ºç¨€æœ‰å•çµæ ¹æˆ–åŒäº”è¡Œçµæ ¹ï¼‰ã€‚</div>
      <button id="startGameBtn">å¼€å§‹ä¿®ç‚¼</button>
    </div>
  </div>

<!-- çµæ ¹æŠ½å–é¢æ¿ï¼šèµ·åä¹‹åå‡ºç° -->
<div id="rootDrawPanel" class="panel root-draw-panel" style="display:none;">
  <h2>æŠ½å–ä½ çš„çµæ ¹</h2>
  <div class="root-draw-subtitle">
    é“å·ï¼š<span id="rootPlayerName">æ— åæ•£ä¿®</span>
  </div>

  <!-- ç®€å•è½¬ç›˜åŒºåŸŸ -->
  <div class="root-wheel-wrapper">
    <div class="root-wheel" id="rootWheel">
      <div class="root-wheel-name" id="rootWheelName">ç‚¹å‡»å¼€å§‹è½¬ç›˜</div>
    </div>
  </div>

  <!-- å½“å‰æŠ½åˆ°çš„çµæ ¹ä¿¡æ¯ -->
  <div class="root-result">
    <div>
      å½“å‰çµæ ¹ï¼š
      <span id="rootResultName" class="spirit-root-tag">æœªæŠ½å–</span>
    </div>
    <div class="root-result-tier">
      å“é˜¶ï¼š<span id="rootResultTier">-</span>
    </div>
    <div class="root-result-desc" id="rootResultDesc">è¯·å…ˆç‚¹å‡»ã€Œå¼€å§‹æŠ½å–ã€ã€‚</div>
  </div>

  <div class="root-draw-controls">
    <button id="btnRootRoll">å¼€å§‹æŠ½å–</button>
    <button id="btnRootReroll" disabled>åˆ·æ–°çµæ ¹ï¼ˆå‰©ä½™ <span id="rootRerollLeft">2</span> æ¬¡ï¼‰</button>
  </div>

  <div class="root-confirm-row">
    <button id="btnRootConfirm" class="btn-main" disabled>ç¡®è®¤æ­¤çµæ ¹å¹¶å¼€å§‹ä¿®è¡Œ</button>
  </div>

  <div class="hint root-warning">
    â€» çµæ ¹ä¸€æ—¦ç¡®è®¤å°†<span class="text-highlight">æ— æ³•æ›´æ”¹</span>ï¼Œè¯·è°¨æ…é€‰æ‹©ã€‚<br>
    ç¨€æœ‰çµæ ¹æ¦‚ç‡æä½ï¼Œè‹¥å¯¹å½“å‰ç»“æœä¸æ»¡æ„ï¼Œå¯ä½¿ç”¨åˆ·æ–°æœºä¼šé‡æ–°æŠ½å–ã€‚
  </div>
</div>

  <!-- æ´—é«“ä¸¹ Â· çµæ ¹é‡å¡‘è½¬ç›˜ -->
  <div id="washRootOverlay" class="overlay-screen">
    <div class="result-card wash-root-card">
      <h2>æ´—é«“ä¸¹ Â· çµæ ¹é‡å¡‘</h2>
      <div class="hint">
        æ´—é«“ä¸¹å¯ä»¥è®©ä½ å°è¯•æŠ½å–ä¸€ç»„æ–°çš„çµæ ¹ï¼Œä¸ä¼šç«‹åˆ»ç”Ÿæ•ˆï¼Œéœ€è¦ä½ æ‰‹åŠ¨é€‰æ‹©æ˜¯å¦æ›¿æ¢ã€‚
      </div>

      <div class="root-result">
        <div>
          å½“å‰çµæ ¹ï¼š
          <span id="washOldRootName" class="spirit-root-tag">æœªè§‰é†’</span>
        </div>
      </div>

      <div class="root-wheel-wrapper">
        <div class="root-wheel" id="washRootWheel">
          <div class="root-wheel-name" id="washRootWheelName">ç‚¹å‡»å¼€å§‹è½¬ç›˜</div>
        </div>
      </div>

      <div class="root-result">
        <div>
          æ–°çµæ ¹ï¼š
          <span id="washRootResultName" class="spirit-root-tag">æœªæŠ½å–</span>
        </div>
        <div class="root-result-tier">
          å“é˜¶ï¼š<span id="washRootResultTier">-</span>
        </div>
        <div class="root-result-desc" id="washRootResultDesc">è¯·å…ˆç‚¹å‡»ã€Œå¼€å§‹è½¬ç›˜ã€ã€‚</div>
      </div>

      <div class="root-draw-controls">
        <button id="btnWashRootRoll">å¼€å§‹è½¬ç›˜</button>
      </div>

      <div class="root-draw-controls">
        <button id="btnWashKeepOld">ä¿ç•™åŸçµæ ¹</button>
        <button id="btnWashReplace" class="btn-main" disabled>æ›¿æ¢ä¸ºæ–°çµæ ¹</button>
      </div>

      <div class="hint">
        <label class="switch-label">
          <input type="checkbox" id="washConfirmToggle" checked />
          <span>æ›¿æ¢çµæ ¹å‰éœ€è¦ç¡®è®¤æç¤º</span>
        </label>
      </div>

      <div class="root-confirm-row">
        <button id="btnWashClose" class="btn-small">å…³é—­</button>
      </div>
    </div>
  </div>

  <!-- æ¸¸å†ç»“ç®— / éšæœºäº‹ä»¶ï¼ˆä»…æ‰‹åŠ¨æˆ˜æ–—æ—¶ä½¿ç”¨ï¼‰ -->
  <div id="battleResultOverlay" class="overlay-screen">
    <div class="result-card">
      <h2 id="resultTitle">æ¸¸å†ç»“æœ</h2>
      <div id="resultSummary" class="result-summary"></div>
      <div id="resultDrops" class="result-drops"></div>
      <div id="resultExtra" class="result-extra"></div>
      <div id="randomEvent" class="result-random"></div>
      <button id="closeResultBtn">è¿”å›</button>
    </div>
  </div>

  <div class="app-container" id="appContainer">
    <!-- é¡¶éƒ¨ -->
    <div class="top-bar">
      <h1>ä»™é€”æ”¾ç½® Â· Demo</h1>
      <div class="subtitle">ä»å‡¡äººå¼€å§‹ï¼Œæ¯ç§’å¸æ”¶ 0.1 ç‚¹çœŸæ°”ï¼Œè¸ä¸Šä¿®ä»™ä¹‹è·¯</div>
      <div class="player-info">
        é“å·ï¼š<span id="playerName">æœªå‘½å</span> Â· çµæ ¹ï¼š<span id="lingRootName">æœªè§‰é†’</span>
      </div>
    </div>

    <!-- ä¸»åŒºåŸŸï¼šå¤šé¡µé¢ -->
    <div class="main-area">
      <!-- ä¿®ç‚¼é¡µ -->
      <div id="pageCultivation" style="width:100%;">
        <div class="stats">
          <div>å½“å‰çœŸæ°”ï¼š<span id="qi">0.0</span></div>
          <div>æ¯ç§’ä¿®ä¸ºå¢é•¿ï¼š<span id="qps">0.0</span> / ç§’</div>
          <div>æ¯æ¬¡æ‰“åè·å¾—ï¼š<span id="qpc">1.0</span> çœŸæ°”</div>
          <div>å½“å‰å¢ƒç•Œï¼š<span id="realm">å‡¡äºº</span></div>
          <div>
            å†ç»ƒå€¼ï¼š<span id="expMainSpan">0</span>
            ï¼ˆçªç ´éœ€æ±‚ï¼š<span id="expReqSpan">â€”</span>ï¼‰
          </div>
          <div class="hint">
            å¢ƒç•Œï¼šå‡¡äºº â†’ è¾Ÿè°· â†’ ç‚¼ä½“ â†’ ç»ƒæ°” â†’ ç­‘åŸº â†’ é‡‘ä¸¹ â†’ å…ƒå©´ â†’ å‡ºçª â†’ å¤§ä¹˜ â†’ æ¸¡åŠ« â†’ åŒ–ç¥ â†’ ä»™ç­ã€‚<br>
            æ¯ä¸ªã€Œå¤§åœ†æ»¡ã€çªç ´åˆ°ä¸‹ä¸€å¤§å¢ƒç•Œï¼Œéœ€è¦è¶³å¤Ÿçš„å†ç»ƒå€¼å¹¶æ‰‹åŠ¨çªç ´ã€‚
          </div>
          <div class="stats-actions">
            <button id="breakthroughBtn" class="btn-small">çªç ´å¢ƒç•Œ</button>
            <button id="saveBtn" class="btn-small">æ‰‹åŠ¨ä¿å­˜</button>
            <button id="resetBtn" class="btn-small">æ¸…ç©ºé‡ä¿®</button>
          </div>
        </div>

        <button id="cultivateBtn" class="btn-main">æ‰“ååçº³ï¼ˆè·å¾—çœŸæ°”ï¼‰</button>

        <div class="panel">
          <h2>ä¿®ä¸ºä¸å±æ€§</h2>
          <div class="hint">
            æ¯æ¬¡è·å¾—çœŸæ°”ï¼Œæœ‰ä¸€å®šæ¦‚ç‡è·å¾—ã€Œèƒ½åŠ›ç‚¹ã€ï¼Œå¯ç”¨äºè‡ªç”±åŠ ç‚¹ï¼ˆæ¦‚ç‡è¾ƒä½ï¼Œä¸»è¦é å¢ƒç•Œè‡ªåŠ¨æˆé•¿ï¼‰ã€‚<br>
            å¯åˆ†é…èƒ½åŠ›ç‚¹ï¼š<span id="abilityPoints">0</span>
          </div>
          <div class="hint">
            å†ç»ƒå€¼ï¼ˆæ¸¸å†ç»éªŒï¼‰ï¼š<span id="experienceSpan">0</span>
            ï¼ˆå½“å‰é¢å¤–ä¼¤å®³åŠ æˆï¼š<span id="experienceBuffSpan">0</span>%ï¼‰
          </div>
          <div class="hint">
            å½“å‰çµçŸ³å‚¨é‡ï¼š<span id="spiritStonesSpan">0</span>
          </div>
          <div class="stats-grid">
            <div class="stat-row">
              <span>åŠ›é‡ï¼ˆæ”»å‡»ä¼¤å®³ï¼‰</span>
              <span class="stat-right">
                <span id="statPower">0</span>
                <button class="btn-plus" data-stat="power">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>ä½“è´¨ï¼ˆç”Ÿå‘½ã€é˜²å¾¡ï¼‰</span>
              <span class="stat-right">
                <span id="statPhysique">0</span>
                <button class="btn-plus" data-stat="physique">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>èº«æ³•ï¼ˆé—ªé¿ã€é€Ÿåº¦ï¼‰</span>
              <span class="stat-right">
                <span id="statAgility">0</span>
                <button class="btn-plus" data-stat="agility">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>ç¥è¯†ï¼ˆè“é‡ã€ç²¾ç¥ï¼‰</span>
              <span class="stat-right">
                <span id="statSpirit">0</span>
                <button class="btn-plus" data-stat="spirit">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>æ ¹éª¨ï¼ˆä½“é­„ã€éŸ§æ€§ï¼‰</span>
              <span class="stat-right">
                <span id="statRoot">0</span>
                <button class="btn-plus" data-stat="root">+</button>
              </span>
            </div>
            <div class="stat-row">
              <span>æ°”è¿ï¼ˆæœºç¼˜ã€æ‰è½ï¼‰</span>
              <span class="stat-right">
                <span id="statLuck">0</span>
                <button class="btn-plus" data-stat="luck">+</button>
              </span>
            </div>
          </div>
        </div>

        <div class="panel">
          <h2>çµæ ¹å¤©èµ‹</h2>
          <div class="hint">
            çµæ ¹ä¸ç›´æ¥æ”¹å˜æˆ˜æ–—æ•°å€¼ï¼Œä½†ä¼šæå¤§å½±å“ä¿®ç‚¼é€Ÿåº¦ã€èƒ½åŠ›ç‚¹æ‰è½ä¸å¥‡é‡è§¦å‘ã€‚<br>
            ä¿®ç‚¼å¿ƒæ³•åï¼Œå¯è¿›ä¸€æ­¥æ”¾å¤§çµæ ¹æ•ˆæœã€‚
            <br>å½“å‰çµæ ¹ç³»ç»ŸåŠ æˆï¼š<span id="lingRootBonusText">ä¿®ç‚¼é€Ÿåº¦ +0% Â· èƒ½åŠ›ç‚¹ +0% Â· å¥‡é‡æƒé‡ +0%</span>
          </div>
          <div id="lingRootTable" class="ling-root-table"></div>
        </div>

        <!-- å¤šå­˜æ¡£ç®¡ç†é¢æ¿ -->
        <div class="panel">
          <h2>å­˜æ¡£ç®¡ç†</h2>
          <div class="hint">
            å½“å‰å­˜æ¡£æ§½ï¼š<span id="activeSlotSpan">1å·</span>ï¼ˆè‡ªåŠ¨ä¿å­˜ä¼šå†™å…¥è¯¥æ§½ä½ï¼‰
          </div>
          <div id="saveSlotList" class="hint" style="margin-top:8px;"></div>
        </div>
      </div>

      <!-- æ¸¸å†é¡µ -->
      <div id="pageBattle" style="width:100%; display:none;">
        <div class="panel">
          <h2>æ¸¸å† Â· è¯•ç‚¼</h2>
          <div id="playerBattleStats" class="hint">å°šæœªè¸å…¥ä¿®è¡Œï¼Œå±æ€§æœªçŸ¥ã€‚</div>
          <div class="hint">
            æ¸¸å†ç›®çš„åœ°ï¼š
            <select id="mapSelect"></select>
          </div>
          <div class="hint">
            ä¸åŒåœ°ç‚¹æ•Œäººå¢ƒç•Œä¸åŒï¼Œè·å¾—çš„çœŸæ°” / å†ç»ƒ / çµçŸ³å¥–åŠ±ä¹Ÿä¸åŒã€‚æ•Œäººè¶Šæ¥è¿‘ä½ å½“å‰å¢ƒç•Œï¼Œå¥–åŠ±è¶Šé«˜ã€‚
          </div>
          <div class="hint">
            <label>
              <input type="checkbox" id="autoBattleToggle">
              è‡ªåŠ¨æˆ˜æ–—ç»“ç®—ï¼ˆå‹¾é€‰åæŒç»­æ¸¸å†ï¼Œä¸å†å¼¹å‡ºç»“ç®—çª—å£ï¼‰
            </label>
          </div>
          <button id="startBattleBtn" class="btn-main">å¼€å§‹æ¸¸å†è¯•ç‚¼</button>
          <div id="battleResult" class="hint"></div>
          <div id="battleLog"></div>
        </div>
      </div>

      <!-- å¸‚é›†é¡µ -->
      <div id="pageShop" style="width:100%; display:none;">
        <div class="panel">
          <h2>çµçŸ³å¸‚é›† Â· æ´åºœ</h2>
          <div class="hint">
            å½“å‰çµçŸ³ï¼š<span id="shopSpiritStones">0</span><br>
            æ´åºœä¼šè‡ªåŠ¨å¸æ”¶å¤©åœ°çµæ°”ï¼Œæ˜¯æŒ‚æœºä¿®ç‚¼çš„æ ¸å¿ƒã€‚
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              è´­ä¹°æ´åºœï¼ˆæ•°é‡å åŠ ï¼‰<br>
              ä»·æ ¼ï¼š<span id="caveCost">0</span> çµçŸ³<br>
              æ´åºœæ•°é‡ï¼š<span id="caveCount">0</span>
            </div>
            <button id="buyCaveBtn">è´­ä¹°æ´åºœ</button>
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              æ´åºœå“è´¨ï¼š<span id="caveQualitySpan">ç®€é™‹æ´åºœ</span><br>
              å½“å‰æ€»æ´åºœåŠ æˆï¼š<span id="caveQpsSpan">0.0</span> çœŸæ°”/ç§’<br>
              å“è´¨å‡çº§æ¶ˆè€—ï¼š<span id="caveUpgradeCost">0</span> çµçŸ³
            </div>
            <button id="upgradeCaveBtn">å‡çº§æ´åºœå“è´¨</button>
          </div>
          <div class="hint">
            å“è´¨è¶Šé«˜ï¼Œæ¯ä¸€åº§æ´åºœæä¾›çš„çœŸæ°”/ç§’è¶Šå¤šã€‚éƒ¨åˆ†æ¸¸å†å¥‡é‡ä¹Ÿå¯èƒ½ç›´æ¥æå‡æ´åºœå“è´¨ã€‚
          </div>
        </div>

        <div class="panel">
          <h2>çµçŸ³å¸‚é›† Â· ä¸¹è¯</h2>
          <div class="hint">
            ä¸¹è¯ä¸»è¦æå‡æ‰“åæ—¶çš„çœŸæ°”æ”¶ç›Šï¼Œæ˜¯å‰æœŸæå‡ä¿®ä¸ºé€Ÿåº¦çš„é‡è¦æ–¹å¼ã€‚
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              è´­ä¹°èšæ°”æ•£ä¸€å±‚ï¼ˆæå‡æ‰“åæ”¶ç›Šï¼‰<br>
              ä»·æ ¼ï¼š<span id="pillCost">0</span> çµçŸ³<br>
              ä¸¹è¯å±‚æ•°ï¼š<span id="pillLevel">1</span>
            </div>
            <button id="buyPillBtn">è´­ä¹°ä¸¹è¯</button>
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              ä¸¹è¯å“è´¨ï¼š<span id="pillQualitySpan">å‡¡å“èšæ°”æ•£</span><br>
              å“è´¨å‡çº§æ¶ˆè€—ï¼š<span id="pillUpgradeCost">0</span> çµçŸ³
            </div>
            <button id="upgradePillBtn">å‡çº§ä¸¹è¯å“è´¨</button>
          </div>
          <div class="hint">
            å“è´¨è¶Šé«˜ï¼Œæ¯ä¸€å±‚ä¸¹è¯æä¾›çš„é¢å¤–æ‰“åçœŸæ°”è¶Šå¤šã€‚æœªæ¥å¯ä»¥åœ¨æ­¤æ‰©å±•æ›´å¤šä¸¹è¯ä¸åŠŸæ³•ã€‚
          </div>
        </div>

        <div class="panel">
          <h2>çµçŸ³å¸‚é›† Â· æ´—é«“ä¸¹</h2>
          <div class="hint">
            æ´—é«“ä¸¹å¯ä»¥é‡å¡‘çµæ ¹ï¼Œä»…å¯¹å·²ç»è§‰é†’çµæ ¹çš„ä¿®å£«æœ‰æ•ˆã€‚
          </div>
          <div class="upgrade">
            <div class="upgrade-info">
              è´­ä¹°ä¸€æšæ´—é«“ä¸¹ï¼Œç«‹å³å¼¹å‡ºçµæ ¹è½¬ç›˜ï¼Œéšæœºç”Ÿæˆä¸€ç»„æ–°çš„çµæ ¹ã€‚<br>
              ä»·æ ¼ï¼š<span id="washPillCost">200</span> çµçŸ³
            </div>
            <button id="buyWashPillBtn">è´­ä¹°æ´—é«“ä¸¹ï¼ˆé‡å¡‘çµæ ¹ï¼‰</button>
          </div>
          <div class="hint">
            è½¬ç›˜ç»“æŸåï¼Œä½ å¯ä»¥é€‰æ‹©ä¿ç•™åŸçµæ ¹ï¼Œæˆ–ç”¨æ–°çš„çµæ ¹æ›¿æ¢ã€‚æ›¿æ¢å‰æ˜¯å¦å¼¹å‡ºç¡®è®¤æç¤ºï¼Œå¯åœ¨å¼¹å‡ºçš„æ´—é«“ç•Œé¢ä¸­åˆ‡æ¢å¼€å…³ã€‚
          </div>
        </div>

        <div class="panel">
          <h2>çµçŸ³å¸‚é›† Â· æ­¦æŠ€</h2>
          <div class="hint">
            åœ¨æ­¤å¯è´­ä¹°åŸºç¡€æ­¦æŠ€å·è½´ï¼Œä¹ å¾—åå°†åœ¨æˆ˜æ–—ä¸­æä¾›æŒç»­å¢ç›Šã€‚
          </div>
          <div id="shopSkillList" class="hint" style="margin-top:8px;"></div>
        </div>
      </div>

      <!-- åŠŸæ³•é¡µ -->
      <div id="pageSkills" style="width:100%; display:none;">
        <div class="panel">
          <h2>åŠŸæ³•æ€»è§ˆ</h2>
          <div class="hint">
            è¿™é‡Œå¯ä»¥æŸ¥çœ‹ä½ å·²ç»ä¿®ç‚¼çš„å¿ƒæ³•ã€æŒæ¡çš„ç§˜ç±ä¸æ­¦æŠ€ã€‚<br>
            å¿ƒæ³•ä¸çµæ ¹å¥‘åˆï¼Œå¯å¤§å¹…æå‡ä¿®ç‚¼é€Ÿåº¦ï¼›ç§˜ç±ä¸æ­¦æŠ€å¤šåœ¨æˆ˜æ–—ä¸­å‘æŒ¥å¨åŠ›ã€‚
          </div>
          <div id="activeMethodInfo" class="hint" style="margin-top:8px;">
            å½“å‰å°šæœªä¿®ç‚¼ä»»ä½•å¿ƒæ³•ã€‚
          </div>
          <div id="knownSkillsList" class="hint" style="margin-top:8px;"></div>
        </div>
      </div>

      <!-- å®—é—¨é¡µ -->
      <div id="pageSect" style="width:100%; display:none;">
        <div class="panel">
          <h2>å®—é—¨ä¼ æ‰¿</h2>
          <div class="hint">
            ä½ å¯åœ¨æ­¤æ¶ˆè€—çµçŸ³ï¼Œå‘è™šæ‹Ÿå®—é—¨è´­ä¹°/å­¦ä¹ åŠŸæ³•ä¸ç§˜ç±ã€‚<br>
            åŠŸæ³•å¤šä¸ºå¿ƒæ³•ï¼Œæ¿€æ´»çµæ ¹æ½œåŠ›å¹¶æå‡ä¿®ç‚¼é€Ÿåº¦ï¼›ç§˜ç±åˆ™åœ¨æˆ˜æ–—ä¸­å‘æŒ¥å·¨å¤§å¨åŠ›ã€‚<br>
            åªèƒ½å­¦ä¹ ä¸è‡ªèº«çµæ ¹ç›¸ç¬¦çš„å¿ƒæ³•/ç§˜ç±ã€‚
          </div>
          <div id="sectOfferList" class="hint" style="margin-top:8px;"></div>
        </div>
      </div>
    </div>

    <!-- åº•éƒ¨å¯¼èˆª -->
    <div class="bottom-nav">
      <div class="nav-item active" data-page="cultivation">
        <div class="nav-icon">â›°ï¸</div>
        <div class="nav-label">ä¿®ç‚¼</div>
      </div>
      <div class="nav-item" data-page="battle">
        <div class="nav-icon">ğŸ§­</div>
        <div class="nav-label">æ¸¸å†</div>
      </div>
      <div class="nav-item" data-page="skills">
        <div class="nav-icon">ğŸ“œ</div>
        <div class="nav-label">åŠŸæ³•</div>
      </div>
      <div class="nav-item" data-page="shop">
        <div class="nav-icon">ğŸ›’</div>
        <div class="nav-label">å¸‚é›†</div>
      </div>
      <div class="nav-item" data-page="sect">
        <div class="nav-icon">â›©ï¸</div>
        <div class="nav-label">å®—é—¨</div>
      </div>
    </div>
  </div>

  <script>
    /* ========== çµæ ¹è®¾å®š & å±‚çº§åŠ æˆï¼ˆåªå½±å“ä¿®ç‚¼ & å¥‡é‡ï¼‰ ========== */

    const LING_ROOTS = [
      // T1
      { id: 'cause',  name: 'å› æœçµæ ¹',  short: 'å› ', tierGroup: 'T1', type: 'special',
        desc: 'ä»¥å› æœä¸ºçº¿ï¼Œç‰µåŠ¨ç»“æœã€‚é€‚åˆã€Œå¤©å‘½æ”¹å†™ã€ã€Œç»“ç•Œåˆ¤å†³ã€ç­‰é«˜ç«¯åŠŸæ³•è·¯çº¿ã€‚' },
      { id: 'time',   name: 'æ—¶é—´çµæ ¹',  short: 'æ—¶', tierGroup: 'T1', type: 'special',
        desc: 'æ„ŸçŸ¥æ—¶é—´æµé€Ÿå˜åŒ–ï¼Œæœªæ¥å¯ä¿®ä¹ ã€Œæ—¶åœã€ã€Œå›æº¯ã€ç­‰é€†å¤©æœ¯å¼ã€‚' },
      { id: 'space',  name: 'ç©ºé—´çµæ ¹',  short: 'ç©º', tierGroup: 'T1', type: 'special',
        desc: 'å¤©ç”Ÿä¸ç©ºé—´æœ‰äº²å’Œï¼Œå¯æŒæ¡ç¬ç§»ã€æŠ˜å ç©ºé—´ã€é¢†åŸŸå‹ç¼©ç­‰èƒ½åŠ›ã€‚' },

      // T2
      { id: 'holy',   name: 'åœ£çµæ ¹',    short: 'åœ£', tierGroup: 'T2', type: 'special',
        desc: 'ç§©åºä¸åº‡æŠ¤çš„è±¡å¾ï¼Œåæ²»ç–—ã€æŠ¤ç›¾ã€å›¢é˜Ÿå¢ç›Šç­‰åœ£èŒè·¯çº¿ã€‚' },
      { id: 'realm',  name: 'ç•Œçµæ ¹',    short: 'ç•Œ', tierGroup: 'T2', type: 'special',
        desc: 'æ“…é•¿æ„ç­‘é¢†åŸŸä¸ç»“ç•Œï¼Œå°†æ¥å¯é•‡å®ˆä¸€æ–¹å°ä¸–ç•Œã€‚' },
      { id: 'light',  name: 'å…‰çµæ ¹',    short: 'å…‰', tierGroup: 'T2', type: 'special',
        desc: 'æŒæ§å…‰ä¸é€Ÿåº¦ï¼Œåå‡€åŒ–ã€çˆ†å‘ä¸é«˜é€Ÿæ–©å‡»ã€‚' },
      { id: 'dark',   name: 'æš—çµæ ¹',    short: 'æš—', tierGroup: 'T2', type: 'special',
        desc: 'ä¸é˜´å½±ã€è…èš€ã€æ½œè¡Œç›¸ä¼´ï¼Œå¯ä¿®æš—å½±æ½œä¼ã€è¯…å’’ç­‰æ­¦æŠ€ã€‚' },

      // T3
      { id: 'dream',  name: 'æ¢¦çµæ ¹',    short: 'æ¢¦', tierGroup: 'T3', type: 'special',
        desc: 'æ¸¸èµ°ç°å®ä¸æ¢¦å¢ƒï¼Œé€‚åˆå¹»æœ¯ã€å¿ƒå¢ƒæ‰°ä¹±ã€å¿ƒé­”åŒ–è§£æ–¹å‘ã€‚' },
      { id: 'spirit', name: 'çµçµæ ¹',    short: 'çµ', tierGroup: 'T3', type: 'special',
        desc: 'çµè§‰æ•é”ï¼Œå¯¹å¤©åœ°æ°”æœºæä¸ºæ•æ„Ÿï¼Œæ“…é•¿æ¢æŸ¥å±æœºä¸æœºç¼˜ã€‚' },
      { id: 'heart',  name: 'å¿ƒçµæ ¹',    short: 'å¿ƒ', tierGroup: 'T3', type: 'special',
        desc: 'å¿ƒæ€§åšéŸ§ï¼Œæƒ…ç»ªå…±é¸£å¼ºçƒˆï¼Œé€‚åˆæ„å¿—å‹åˆ¶ã€æ–—å¿—ç‡ƒçƒ§è·¯çº¿ã€‚' },

      // T4
      { id: 'ice',    name: 'å†°çµæ ¹',    short: 'å†°', tierGroup: 'T4', type: 'special',
        desc: 'ä¸»æŒå¯’å†°å°é”ä¸å‡é€Ÿï¼Œæˆ˜æ–—è¡¨ç°å¼ºåŠ¿ã€‚' },
      { id: 'thunder',name: 'é›·çµæ ¹',    short: 'é›·', tierGroup: 'T4', type: 'special',
        desc: 'é›·éœ†ä¸‡é’§ï¼Œåå¼ºçˆ†å‘ä¸éº»ç—¹æ‰“æ–­ï¼Œæ˜¯å‰æœŸæˆ˜æ–—åˆ©å™¨ã€‚' },

      // T5 äº”è¡Œï¼Œå¯ç»„åˆä¸ºåŒçµæ ¹
      { id: 'metal',  name: 'é‡‘çµæ ¹',    short: 'é‡‘', tierGroup: 'T5', type: 'basic',
        desc: 'é”‹é”æ”»ä¼ä¹‹é“ï¼Œé€‚åˆå‰‘ä¿®ã€æªä¿®ç­‰é”‹é”æµæ´¾ã€‚' },
      { id: 'wood',   name: 'æœ¨çµæ ¹',    short: 'æœ¨', tierGroup: 'T5', type: 'basic',
        desc: 'ç”Ÿé•¿ä¸æ²»æ„ˆä¹‹æœ¬æºï¼Œæ“…é•¿å›å¤ä¸è—¤è”“ç¼ ç»•ã€‚' },
      { id: 'water',  name: 'æ°´çµæ ¹',    short: 'æ°´', tierGroup: 'T5', type: 'basic',
        desc: 'æŸ”éŸ§å¤šå˜ï¼Œå¯å€Ÿæ°´åŠ¿å¸åŠ›ï¼Œåèº«æ³•ä¸åŒ–è§£ã€‚' },
      { id: 'fire',   name: 'ç«çµæ ¹',    short: 'ç«', tierGroup: 'T5', type: 'basic',
        desc: 'çƒ­çƒˆçˆ†è£‚ï¼Œåçˆ†å‘è¾“å‡ºä¸æŒç»­ç¼çƒ§ã€‚' },
      { id: 'earth',  name: 'åœŸçµæ ¹',    short: 'åœŸ', tierGroup: 'T5', type: 'basic',
        desc: 'ç¨³å›ºåšé‡ï¼Œé€‚åˆé˜²å¾¡ã€å²©ç›¾ã€æŠ¤ä½“ç­‰è·¯çº¿ã€‚' }
    ];


    // çµæ ¹è¯¦ç»†ç­–åˆ’é…ç½®ï¼šç”¨äºæè¿°æˆ˜æ–—/ç”Ÿäº§/ç³»ç»Ÿå‘å®šä½
    const LING_ROOTS_CONFIG = {
      metal: {
        id: 'metal',
        name: 'é‡‘çµæ ¹',
        tierGroup: 'T5',
        foundationRole: 'æ”»ä¼ä¹‹é”',
        battle: 'ç‰©ç†æ”»å‡»ã€ç ´ç”²ã€æš´å‡»æå‡ï¼Œæ“…é•¿å¿«é€Ÿå‡»æ€ä¸ç ´ç”²è¾“å‡ºã€‚',
        production: 'ç‚¼å™¨ä¸“ç²¾ï¼šæ‰“é€ æ­¦å™¨ã€é˜²å…·æ—¶æˆåŠŸç‡ä¸å“è´¨æå‡ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šçˆ†å‘è¾“å‡º', 'ç”Ÿäº§ï¼šç‚¼å™¨']
      },
      wood: {
        id: 'wood',
        name: 'æœ¨çµæ ¹',
        tierGroup: 'T5',
        foundationRole: 'ç”Ÿæœºä¸æ¢å¤',
        battle: 'æŒç»­æ²»ç–—ã€æŠ¤ç›¾ã€å¸è¡€ç±»æ•ˆæœå¢å¼ºï¼Œé€‚åˆæ‹–é•¿æˆ˜æ–—ã€‚',
        production: 'çµæ¤ç§æ¤ä¸è¯è‰åŸ¹è‚²æ•ˆç‡æé«˜ï¼Œä¸ºç‚¼ä¸¹æä¾›å¤§é‡åŸææ–™ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šç»­èˆªå›å¤', 'ç”Ÿäº§ï¼šç§æ¤/è¯ç”°']
      },
      water: {
        id: 'water',
        name: 'æ°´çµæ ¹',
        tierGroup: 'T5',
        foundationRole: 'æµè½¬ä¸èµ„æº',
        battle: 'å‡é€Ÿã€æµè¡€ã€æŒç»­ä¼¤å®³ç­‰â€œæ¶ˆè€—æˆ˜â€èƒ½åŠ›çªå‡ºã€‚',
        production: 'ç‚¼ä¸¹è¾…åŠ©ï¼šé™ä½ç‚¼ä¸¹å¤±è´¥ç‡ï¼Œé€‚åˆé‡äº§ä½ä¸­é˜¶ä¸¹è¯ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šæ¶ˆè€—æ§åœº', 'ç³»ç»Ÿï¼šæŒ‚æœº/æ‰è½åŠ æˆé¢„ç•™']
      },
      fire: {
        id: 'fire',
        name: 'ç«çµæ ¹',
        tierGroup: 'T5',
        foundationRole: 'çˆ†å‘ä¸å±é™©',
        battle: 'é«˜çˆ†å‘èŒƒå›´ä¼¤å®³ï¼Œæ¸…æ€ªæ•ˆç‡æé«˜ï¼Œä½†å®¹æ˜“è‡ªä¼¤æˆ–èµ°ç«å…¥é­”ã€‚',
        production: 'é«˜æ¸©ç›¸å…³çš„ç‚¼å™¨ã€ç‚¼ä¸¹æœ‰é¢å¤–ç«å€™æŒæ§åŠ æˆã€‚',
        systemTags: ['æˆ˜æ–—ï¼šé«˜çˆ†AOE', 'ç³»ç»Ÿï¼šå¿ƒé­”/é£é™©ç©æ³•é’©å­']
      },
      earth: {
        id: 'earth',
        name: 'åœŸçµæ ¹',
        tierGroup: 'T5',
        foundationRole: 'é˜²å¾¡ä¸ç¨³å›º',
        battle: 'é˜²å¾¡ã€å‡ä¼¤ã€æ ¼æŒ¡ã€åä¼¤å¼ºåŒ–ï¼Œé€‚åˆä½œä¸ºå‰æ’è‚‰ç›¾ã€‚',
        production: 'é‡‡çŸ¿ä¸æŒ–å®æ”¶ç›Šæé«˜ï¼Œé€‚åˆæŒ–æ˜åœ°åº•ç§˜å¢ƒä¸çŸ¿è„‰ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šå¦å…‹/åä¼¤', 'ç³»ç»Ÿï¼šæ¢ç´¢/çŸ¿è—']
      },

      ice: {
        id: 'ice',
        name: 'å†°çµæ ¹',
        tierGroup: 'T4',
        foundationRole: 'æ§åˆ¶ä¸“å®¶',
        battle: 'å†»ç»“ã€å‡é€Ÿã€æ˜“ä¼¤ç­‰ç¾¤ä½“æ§åˆ¶å¼ºåŠ¿ï¼Œé€‚åˆé«˜éš¾ç§˜å¢ƒæ§åœºã€‚',
        production: 'æš‚æ— ä¸“å±ç”Ÿäº§åŠ æˆï¼Œå¯ä¸æ°´/åœŸç³»ç©æ³•è”åŠ¨ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šå¼ºæ§/å‡é€Ÿ']
      },
      thunder: {
        id: 'thunder',
        name: 'é›·çµæ ¹',
        tierGroup: 'T4',
        foundationRole: 'é«˜é€Ÿçˆ†ç ´',
        battle: 'æ”»é€Ÿã€è¿å‡»ã€é—ªç”µé“¾æ¡ä¼¤å®³ï¼Œæ¸…å›¾ä¸å¤šç›®æ ‡ä½œæˆ˜å¼ºã€‚',
        production: 'æ¶ˆè€—å“ä¸ç¬¦ç¯†ç±»é“å…·å¯ç»‘å®šâ€œé›·å‡»â€ç‰¹æ•ˆã€‚',
        systemTags: ['æˆ˜æ–—ï¼šé«˜é¢‘è¾“å‡º', 'ç³»ç»Ÿï¼šé«˜æ¶ˆè€—é«˜æ”¶ç›Š']
      },
      heart: {
        id: 'heart',
        name: 'å¿ƒçµæ ¹',
        tierGroup: 'T3',
        foundationRole: 'æ‚Ÿæ€§ä¸å¿ƒå¢ƒ',
        battle: 'å¿ƒå¢ƒç±»æŠ€èƒ½å¼ºåŒ–ï¼Œå¯¹å¿ƒé­”ã€ææƒ§ã€æ··ä¹±ç­‰çŠ¶æ€æ›´ç¨³å®šã€‚',
        production: 'å¿ƒæ³•ç»éªŒä¸æ‚Ÿæ€§åŠ æˆï¼Œæ›´æ˜“è§£é”æ–°æŠ€èƒ½æˆ–éšè—æŠ€ã€‚',
        systemTags: ['ç³»ç»Ÿï¼šæ‚Ÿæ€§/å¤©èµ‹æ ‘', 'äº‹ä»¶ï¼šå¿ƒé­”/æ¸¡åŠ«åŠ æˆ']
      },
      spirit: {
        id: 'spirit',
        name: 'çµçµæ ¹',
        tierGroup: 'T3',
        foundationRole: 'çµå® ä¸è‡ªåŠ¨åŒ–',
        battle: 'å¬å”¤çµå® ã€çµä»†ã€å‚€å„¡æµï¼Œåå¤šå•ä½ä½œæˆ˜ã€‚',
        production: 'çµå® å¯ä»£æ›¿ç©å®¶æ‰§è¡Œé‡‡é›†ã€ç§æ¤ç­‰â€œè‡ªåŠ¨åŒ–â€ä»»åŠ¡ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šå¬å”¤æµ', 'ç³»ç»Ÿï¼šæŒ‚æœº/è‡ªåŠ¨å¯»å®']
      },
      dream: {
        id: 'dream',
        name: 'æ¢¦çµæ ¹',
        tierGroup: 'T3',
        foundationRole: 'æ¢¦å¢ƒä¸ç¦»çº¿æ”¶ç›Š',
        battle: 'å¹»æœ¯ã€è¿·æƒ‘ã€é™å‘½ä¸­ç­‰è™šå®éš¾è¾¨çš„æ¢¦å¢ƒç³»èƒ½åŠ›ã€‚',
        production: 'ç¦»çº¿æ”¶ç›Šå€ç‡æå‡ï¼Œå¯å¼€å¯â€œæ¢¦å¢ƒç§˜å¢ƒâ€ï¼ˆç¦»çº¿æ¨è¿›ç©æ³•ï¼‰ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šå¹»æœ¯/æ§åˆ¶', 'ç³»ç»Ÿï¼šç¦»çº¿æ”¶ç›Š']
      },

      dark: {
        id: 'dark',
        name: 'æš—çµæ ¹',
        tierGroup: 'T2',
        foundationRole: 'é«˜é£é™©é«˜æ”¶ç›Š',
        battle: 'æ®‹è¡€å¢ä¼¤ã€æš—å±æ€§çœŸä¼¤ç­‰ï¼Œè¶Šå±æ€¥è¶Šå¼ºã€‚',
        production: 'é€‚åˆç‚¼åˆ¶ç¦è¯ã€é‚ªå™¨ç­‰é«˜é£é™©äº§ç‰©ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šæå‘½æµ', 'ç³»ç»Ÿï¼šå •è½/ç†æ€§å€¼ç©æ³•']
      },
      light: {
        id: 'light',
        name: 'å…‰çµæ ¹',
        tierGroup: 'T2',
        foundationRole: 'ä¿å‘½ä¸è§£å„',
        battle: 'æŠ¤ç›¾ã€å‡€åŒ–ã€å¤æ´»ã€å›¢é˜Ÿå¢ç›Šï¼Œä¸ºå¼ºåŠ›è¾…åŠ©å‘çµæ ¹ã€‚',
        production: 'ä¸â€œä¿åº•â€â€œå¹¸è¿â€ç±»æœºåˆ¶ç»‘å®šï¼Œé™ä½å¤±è´¥æƒ©ç½šã€‚',
        systemTags: ['æˆ˜æ–—ï¼šå¥¶/ä¿æŠ¤', 'ç³»ç»Ÿï¼šä¿åº•/è§£å„']
      },
      realm: {
        id: 'realm',
        name: 'ç•Œçµæ ¹',
        tierGroup: 'T2',
        foundationRole: 'ç§˜å¢ƒä¸åœ°å›¾æ”¯é…',
        battle: 'åœ¨ç§˜å¢ƒå†…è·å¾—é¢†åŸŸåŠ æˆï¼Œå¯æ”¹å˜åœ°å½¢ä¸æˆ˜åœºè§„åˆ™ã€‚',
        production: 'ç§˜å¢ƒèµ„æºé‡‡é›†åŠ æˆï¼Œæ˜¯æ¢é™©å®¶ä¸å¼€å›¾å…šçš„æœ€çˆ±ã€‚',
        systemTags: ['ç³»ç»Ÿï¼šåœ°å›¾/ç§˜å¢ƒ/é¢†åŸŸ']
      },
      holy: {
        id: 'holy',
        name: 'åœ£çµæ ¹',
        tierGroup: 'T2',
        foundationRole: 'æ°”è¿ä¸åº‡æŠ¤',
        battle: 'å‡å¼±å¤©åŠ«ã€å¿ƒé­”ç­‰æƒ©ç½šï¼Œè¾…åŠ©ä¸åº‡æŠ¤å‹èƒ½åŠ›çªå‡ºã€‚',
        production: 'å¥‡é‡ã€ä»»åŠ¡å“è´¨ã€NPCå¥½æ„Ÿç­‰äº‹ä»¶æƒé‡æå‡ã€‚',
        systemTags: ['ç³»ç»Ÿï¼šæ°”è¿/å¥‡é‡', 'äº‹ä»¶ï¼šæ¸¡åŠ«å‡ä¼¤']
      },

      space: {
        id: 'space',
        name: 'ç©ºé—´çµæ ¹',
        tierGroup: 'T1',
        foundationRole: 'ä½ç½®ä¸æ ¼å±€',
        battle: 'ç¬ç§»ã€ä½ç§»ã€é—ªé¿ä¸æ‹‰æ‰¯ï¼Œææ“…é•¿èµ°ä½ä¸é£ç­ã€‚',
        production: 'èƒŒåŒ…æ ¼å­ã€ä»“åº“ã€çµå® æ ç­‰â€œç©ºé—´ä½â€ä¸Šé™æå‡ã€‚',
        systemTags: ['æˆ˜æ–—ï¼šä½ç§»/é—ªé¿', 'ç³»ç»Ÿï¼šæ ¼å­/é¢å¤–æ§½ä½']
      },
      time: {
        id: 'time',
        name: 'æ—¶é—´çµæ ¹',
        tierGroup: 'T1',
        foundationRole: 'åŠ é€Ÿä¸å‹ç¼©',
        battle: 'ç¼©çŸ­å†·å´ã€åŠ å¿«æŒç»­ä¼¤å®³/æ²»ç–—Tickï¼Œæ—¶é—´å‡é€Ÿæ§åˆ¶ã€‚',
        production: 'ä¿®ç‚¼ã€ç‚¼ä¸¹ã€å»ºé€ ç­‰è€—æ—¶è¡Œä¸ºæ•´ä½“åŠ é€Ÿï¼Œä½†èµ„æºæ¶ˆè€—ä¹Ÿæ›´å¿«ã€‚',
        systemTags: ['ç³»ç»Ÿï¼šå…¨å±€åŠ é€Ÿ', 'æˆ˜æ–—ï¼šå†·å´ç¼©å‡']
      },
      cause: {
        id: 'cause',
        name: 'å› æœçµæ ¹',
        tierGroup: 'T1',
        foundationRole: 'è½®å›ä¸é€†å¤©æ”¹å‘½',
        battle: 'å‰æœŸæ•°å€¼å¹³å¹³ï¼Œä¸­åæœŸä¸è½®å›/å› æœç‚¹ç³»ç»Ÿæ·±åº¦ç»‘å®šã€‚',
        production: 'å¯é‡ç½®çµæ ¹ã€åŠŸæ³•ã€å¤©èµ‹ä»¥â€œæ´—ç‰Œâ€ï¼Œä¿ç•™å› æœåŠ æˆã€‚',
        systemTags: ['ç³»ç»Ÿï¼šè½®å›/æ´—ç»ƒ/ç»ˆå±€æˆé•¿']
      }
    };


    // äº”è¡ŒåŒçµæ ¹ç»„åˆæ•ˆæœï¼ˆä»…ç”¨äºå±•ç¤ºåç§°ä¸è¯´æ˜ï¼Œæ•°å€¼åŠ æˆç”± getLingRootTierMeta æ§åˆ¶ï¼‰
    const DUAL_BASIC_RELATIONS = {
      'metal-wood': {
        title: 'é‡‘æœ¨åŒä¿®',
        desc: 'é‡‘å±ä¹‹é”ä¸æœ¨ä¹‹ç”Ÿé•¿å¹¶å­˜ï¼Œé€‚åˆèµ°æ”»å®ˆå…¼å¤‡è·¯çº¿ï¼Œå‰æœŸè¾“å‡ºé¡ºæ»‘ï¼Œä¸­åæœŸæˆé•¿ç¨³å®šã€‚'
      },
      'metal-water': {
        title: 'é‡‘æ°´çŒé”‹',
        desc: 'é‡‘ä¸»æ€ä¼ï¼Œæ°´ä¸»èµ„æºï¼Œæ—¢èƒ½æ‰“å‡»æ•Œäººï¼Œåˆåå‘æ‰è½ä¸èµ„æºè·å–ï¼Œæ˜¯â€œæ‰“å·¥ä¿®ä»™â€çš„å¸¸è§ä½“è´¨ã€‚'
      },
      'metal-fire': {
        title: 'ç‚é‡‘ç‚¼ç‹±',
        desc: 'é”‹åˆƒå ç«ï¼Œçˆ†å‘æé«˜ï¼Œä½†ä¿®è¡Œè·¯ä¸Šæ›´å®¹æ˜“èµ°ç«å…¥é­”ï¼Œé€‚åˆè¿½æ±‚æè‡´è¾“å‡ºçš„ç–¯æ‰¹å‰‘ä¿®ã€‚'
      },
      'metal-earth': {
        title: 'å±±å²³é‡‘åˆš',
        desc: 'åœŸä¹‹ç¨³å›ºæ‰˜ä¸¾é‡‘ä¹‹æ”»å‡»ï¼Œæ”»é˜²å…¼å¤‡ï¼Œé€‚åˆå‰æ’ã€å¦åˆ€æµä¿®å£«ï¼Œæˆ˜åŠ›æ‰å®ã€‚'
      },
      'wood-water': {
        title: 'çµæœ¨ç”˜æ³‰',
        desc: 'æœ¨ä¸»ç”Ÿæœºï¼Œæ°´ä¸»æ»‹å…»ï¼Œå›å¤ä¸ç»­èˆªèƒ½åŠ›æä½³ï¼Œé€‚åˆåŒ»ç”Ÿã€è¾…åŠ©ã€é•¿çº¿å…»æˆæµã€‚'
      },
      'wood-fire': {
        title: 'ç„šæ—ç‡ƒæœ¨',
        desc: 'æœ¨ä¸ºè–ªæŸ´ï¼Œç«å€Ÿæœ¨åŠ¿ï¼Œçˆ†å‘ä¸èŒƒå›´ä¼¤å®³éƒ½å¼ºåŠ›ï¼Œä½†èµ„æºæ¶ˆè€—åé«˜ï¼Œå¯¹ç©å®¶æ“ä½œä¸è§„åˆ’è¦æ±‚æ›´é«˜ã€‚'
      },
      'wood-earth': {
        title: 'é’è—¤å›ºå²­',
        desc: 'æœ¨åœŸå¹¶ç”Ÿï¼Œå¦‚è—¤ç¼ å±±ï¼Œåå‘æ§åˆ¶ä¸é˜²å®ˆï¼Œé€‚åˆé˜µåœ°æˆ˜ã€å®ˆç‚¹ç±»ç©æ³•ã€‚'
      },
      'water-fire': {
        title: 'å¯’ç‚ç›¸æµ',
        desc: 'å†·çƒ­äº¤æ›¿ï¼Œæ”»å®ˆä¸€ä½“ï¼Œæ—¢èƒ½æ‰“è¾“å‡ºåˆèƒ½æ§åœºï¼Œæ“ä½œä¸Šæ›´è€ƒéªŒèŠ‚å¥æ„Ÿã€‚'
      },
      'water-earth': {
        title: 'æ²¼æ³½çŸ¿è„‰',
        desc: 'æ°´æ¶¦åœŸã€åœŸè½½æ°´ï¼Œåå‘å‡é€Ÿã€æŸç¼šä¸èµ„æºæœé›†ï¼Œåœ¨æ¢ç´¢ä¸æŒ–å®ç©æ³•ä¸­è¡¨ç°çªå‡ºã€‚'
      },
      'fire-earth': {
        title: 'ç†”å²©å£å’',
        desc: 'ç«ç‚¼åœŸæˆå²©ï¼Œæ”»é˜²ä¸€ä½“ï¼Œé€‚åˆç«™æ¡©è¾“å‡ºä¸åå‡»æµæ´¾ï¼Œåœ¨é«˜å‹æˆ˜æ–—ä¸­å°¤ä¸ºç¨³å®šã€‚'
      }
    };


    const LING_TIER_META = {
      none:       { label: 'æ— çµæ ¹åŠ æˆ',         qiMult: 1.0,  abilityMult: 1.0, eventMult: 1.0 },
      T1:         { label: 'T1 è¶…é™çµæ ¹',       qiMult: 3.0,  abilityMult: 2.5, eventMult: 2.5 },
      T2:         { label: 'T2 é«˜ç»´è§„åˆ™çµæ ¹',   qiMult: 2.2,  abilityMult: 1.4, eventMult: 1.6 },
      T3:         { label: 'T3 çµæ€§/æ„è¯†çµæ ¹',  qiMult: 2.0,  abilityMult: 1.0, eventMult: 1.4 },
      T4:         { label: 'T4 è‡ªç„¶æˆ˜æ–—çµæ ¹',   qiMult: 1.4,  abilityMult: 1.0, eventMult: 1.0 },
      T5_single:  { label: 'T5 å•äº”è¡Œçµæ ¹',     qiMult: 1.0,  abilityMult: 1.0, eventMult: 1.0 },
      T5_double:  { label: 'T5 åŒäº”è¡Œçµæ ¹',     qiMult: 1.25, abilityMult: 1.0, eventMult: 1.0 }
    };

    function getBasicRoots()  { return LING_ROOTS.filter(r => r.type === 'basic'); }
    function getSpecialRoots(){ return LING_ROOTS.filter(r => r.type === 'special'); }

    function getDualBasicRelation(roots) {
      if (!roots || roots.length !== 2) {
        return { type: 'neutral', label: 'T5 åŒçµæ ¹', descExtra: '', comboName: '' };
      }
      const [r1, r2] = roots;
      if (r1.type !== 'basic' || r2.type !== 'basic') {
        return { type: 'neutral', label: 'T5 åŒçµæ ¹', descExtra: '', comboName: '' };
      }
      const a = r1.id, b = r2.id;

      function match(p1, p2) {
        return (a === p1 && b === p2) || (a === p2 && b === p1);
      }

      let relType = 'neutral';
      let label = 'T5 åŒçµæ ¹';
      let descExtra = 'ä¸¤ç§äº”è¡Œå¹¶å­˜ï¼Œæ—¢æœ‰å¤šæ ·å˜åŒ–ï¼Œä¹Ÿéœ€è°¨æ…è°ƒå’Œã€‚';

      // ç›¸ç”Ÿï¼šæœ¨ç«ã€ç«åœŸã€åœŸé‡‘ã€é‡‘æ°´ã€æ°´æœ¨
      if (match('wood', 'fire') || match('fire', 'earth') || match('earth', 'metal')
        || match('metal', 'water') || match('water', 'wood')) {
        relType = 'synergy';
        label = 'T4.5 ç›¸ç”ŸåŒçµæ ¹';
        descExtra = 'ä¸¤ç§äº”è¡Œç›¸ç”Ÿï¼Œä¿®è¡Œè·¯é€”æ›´é¡ºæ»‘ï¼Œèƒ½åŠ›ç‚¹è·å–ç•¥æœ‰æå‡ã€‚';
      }
      // ç›¸å…‹ï¼šé‡‘æœ¨ï¼Œæœ¨åœŸï¼ŒåœŸæ°´ï¼Œæ°´ç«ï¼Œç«é‡‘
      else if (match('metal', 'wood') || match('wood', 'earth') || match('earth', 'water')
        || match('water', 'fire') || match('fire', 'metal')) {
        relType = 'clash';
        label = 'T5 ç›¸å…‹åŒçµæ ¹';
        descExtra = 'ä¸¤ç§äº”è¡Œç›¸å…‹ï¼Œä¿®è¡Œè·¯ä¸Šæ³¢æ¾œä¸æ–­ï¼Œå´æ›´å®¹æ˜“æ¿€å‘å‘½è¿æ³¢åŠ¨ä¸å¥‡é‡ã€‚';
      }

      // æŸ¥æ‰¾é¢„è®¾çš„ç»„åˆåç§°ä¸æ›´ç»†èŠ‚çš„è¯´æ˜
      let comboName = '';
      if (typeof DUAL_BASIC_RELATIONS !== 'undefined' && DUAL_BASIC_RELATIONS) {
        const key = [a, b].sort().join('-');
        const cfg = DUAL_BASIC_RELATIONS[key];
        if (cfg) {
          if (cfg.title) comboName = cfg.title;
          if (cfg.desc) descExtra = cfg.desc;
        }
      }

      return { type: relType, label, descExtra, comboName };
    }

    function getLingRootTierMeta() {
      if (!lingRoots || lingRoots.length === 0) return LING_TIER_META.none;

      const hasSpecial = lingRoots.some(r => r.type === 'special');
      if (hasSpecial) {
        const order = ['T1', 'T2', 'T3', 'T4'];
        let bestTier = 'T4';
        let bestIndex = order.length;
        lingRoots.forEach(r => {
          if (r.type === 'special') {
            const idx = order.indexOf(r.tierGroup);
            if (idx !== -1 && idx < bestIndex) {
              bestIndex = idx;
              bestTier = r.tierGroup;
            }
          }
        });
        const meta = { ...LING_TIER_META[bestTier] };
        return meta;
      } else {
        if (lingRoots.length >= 2) {
          const meta = { ...LING_TIER_META.T5_double };
          const rel = getDualBasicRelation(lingRoots);
          if (rel.type === 'synergy') {
            meta.abilityMult *= 1.2; // ç›¸ç”Ÿï¼šèƒ½åŠ›ç‚¹ç•¥å¢
          } else if (rel.type === 'clash') {
            meta.eventMult *= 1.2;   // ç›¸å…‹ï¼šå¥‡é‡æ¦‚ç‡ç•¥å¢
          }
          return meta;
        }
        return LING_TIER_META.T5_single;
      }
    }

    function getLingRootDisplayNameFrom(roots) {
      if (!roots || roots.length === 0) return 'æœªè§‰é†’';
      if (roots.length === 1) return roots[0].name;
      const bothBasic = roots.every(r => r.type === 'basic');
      if (bothBasic) {
        return `${roots[0].short}${roots[1].short}åŒçµæ ¹`;
      }
      return roots.map(r => r.name).join(' / ');
    }

    function getLingRootDisplayName() {
      return getLingRootDisplayNameFrom(lingRoots);
    }

    // çµæ ¹é«˜å…‰é¢œè‰² class æ˜ å°„
    const ROOT_COLOR_CLASS_MAP = {
      cause:   'root-color-cause',
      time:    'root-color-time',
      space:   'root-color-space',
      holy:    'root-color-holy',
      realm:   'root-color-realm',
      light:   'root-color-light',
      dark:    'root-color-dark',
      dream:   'root-color-dream',
      spirit:  'root-color-spirit',
      heart:   'root-color-heart',
      ice:     'root-color-ice',
      thunder: 'root-color-thunder',
      metal:   'root-color-metal',
      wood:    'root-color-wood',
      water:   'root-color-water',
      fire:    'root-color-fire',
      earth:   'root-color-earth'
    };

    const ROOT_COLOR_CLASS_LIST = Object.values(ROOT_COLOR_CLASS_MAP);

    function applyLingRootColor(el, roots) {
      if (!el) return;
      ROOT_COLOR_CLASS_LIST.forEach(c => el.classList.remove(c));
      if (!roots || roots.length === 0) return;
      const first = roots[0];
      const cls = ROOT_COLOR_CLASS_MAP[first.id];
      if (cls) el.classList.add(cls);
    }

    // æŠ½çµæ ¹ï¼š15% ç¨€æœ‰å•çµæ ¹ï¼›å…¶ä½™ä¸ºå•/åŒäº”è¡Œ
    function generateLingRoots() {
      const specialPool = getSpecialRoots();
      const basicPool = getBasicRoots();
      const roll = Math.random();

      if (roll < 0.15) {
        const idx = Math.floor(Math.random() * specialPool.length);
        return [specialPool[idx]];
      } else {
        const r2 = Math.random();
        if (r2 < 0.4) {
          const idx = Math.floor(Math.random() * basicPool.length);
          return [basicPool[idx]];
        } else {
          const idx1 = Math.floor(Math.random() * basicPool.length);
          let idx2 = Math.floor(Math.random() * basicPool.length);
          while (idx2 === idx1) idx2 = Math.floor(Math.random() * basicPool.length);
          return [basicPool[idx1], basicPool[idx2]];
        }
      }
    }

    /* ========== åŠŸæ³• / ç§˜ç± / æ­¦æŠ€ å®šä¹‰ ========== */

    const SKILL_RARITY_META = {
      common:    { label: 'å‡¡å“', className: 'skill-rarity-common' },
      uncommon:  { label: 'ç½•è§', className: 'skill-rarity-uncommon' },
      rare:      { label: 'ç¨€æœ‰', className: 'skill-rarity-rare' },
      epic:      { label: 'çå“', className: 'skill-rarity-epic' },
      legendary: { label: 'ç»å“', className: 'skill-rarity-legendary' },
      mythic:    { label: 'ä»™æ³•', className: 'skill-rarity-mythic' }
    };

    // åŠŸæ³• / ç§˜ç± / æ­¦æŠ€ å®šä¹‰
// type: method=å¿ƒæ³•, manual=ç§˜ç±, technique=æ­¦æŠ€
// source: sect / sectAndDrop / shop / shopAndDrop / drop
const ALL_SKILLS = {
  /* ======================
   *  T1 è¶…é™çµæ ¹ Â· å¿ƒæ³•
   * ====================== */

  // å› æœçµæ ¹
  method_cause_silk: {
    id: 'method_cause_silk',
    name: 'å¿ƒæ³•Â·å› æœç‰µä¸',
    type: 'method',
    rarity: 'mythic',
    source: 'sect',
    price: 100000,
    qiSpeedBonus: 0.5, // +50% ä¿®ç‚¼é€Ÿåº¦
    requirement: {
      type: 'rootAnyOf',
      ids: ['cause']
    },
    desc: 'ä»¥å¿ƒå¿µä¸ºä¸ï¼Œå‹¾è¿å¤©åœ°å› æœã€‚é™å®šå› æœçµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +50%ã€‚'
  },

  // æ—¶é—´çµæ ¹ï¼ˆæ—§ç¤ºä¾‹ä¿ç•™ï¼‰
  method_time_flow: {
    id: 'method_time_flow',
    name: 'å¿ƒæ³•Â·æ—¶å¦‚å¿ƒæµ',
    type: 'method',
    rarity: 'mythic',
    source: 'sect',
    price: 100000,
    qiSpeedBonus: 0.5, // +50% ä¿®ç‚¼é€Ÿåº¦
    requirement: {
      type: 'rootAnyOf',
      ids: ['time']
    },
    desc: 'æ—¶é—´å¦‚å¿ƒä¸­æºªæµï¼Œå¿µèµ·å³æµè½¬ã€‚é™å®šæ—¶é—´çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +50%ã€‚'
  },

  // ç©ºé—´çµæ ¹
  method_space_fold: {
    id: 'method_space_fold',
    name: 'å¿ƒæ³•Â·ç©ºç›¸æŠ˜å ',
    type: 'method',
    rarity: 'mythic',
    source: 'sect',
    price: 100000,
    qiSpeedBonus: 0.5,
    requirement: {
      type: 'rootAnyOf',
      ids: ['space']
    },
    desc: 'æ„Ÿæ‚Ÿä¸‡ç‰©ã€Œç©ºç›¸ã€ï¼ŒæŠ˜å ç©ºé—´è„‰ç»œã€‚é™å®šç©ºé—´çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +50%ã€‚'
  },

  /* ======================
   *  T2 é«˜ç»´è§„åˆ™çµæ ¹ Â· å¿ƒæ³•
   * ====================== */

  // åœ£çµæ ¹
  method_holy_radiance: {
    id: 'method_holy_radiance',
    name: 'å¿ƒæ³•Â·åœ£è¾‰åŒå°˜è¯€',
    type: 'method',
    rarity: 'legendary',
    source: 'sect',
    price: 60000,
    qiSpeedBonus: 0.4,
    requirement: {
      type: 'rootAnyOf',
      ids: ['holy']
    },
    desc: 'åœ£è¾‰å…¥å°˜ï¼Œä¸æŸ“ä¸€å°˜ã€‚é™å®šåœ£çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +40%ã€‚'
  },

  // ç•Œçµæ ¹
  method_realm_pillar: {
    id: 'method_realm_pillar',
    name: 'å¿ƒæ³•Â·ç•Œé•‡å¯°å®‡',
    type: 'method',
    rarity: 'legendary',
    source: 'sect',
    price: 60000,
    qiSpeedBonus: 0.4,
    requirement: {
      type: 'rootAnyOf',
      ids: ['realm']
    },
    desc: 'ä»¥è‡ªèº«ä¸ºç•ŒæŸ±ï¼Œé•‡å‹ä¸€åŸŸæ°”æœºã€‚é™å®šç•Œçµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +40%ã€‚'
  },

  // å…‰çµæ ¹
  method_light_purify: {
    id: 'method_light_purify',
    name: 'å¿ƒæ³•Â·å…‰æ›œå‡€ä¸–ç¯‡',
    type: 'method',
    rarity: 'legendary',
    source: 'sect',
    price: 60000,
    qiSpeedBonus: 0.4,
    requirement: {
      type: 'rootAnyOf',
      ids: ['light']
    },
    desc: 'çº³ä¸‡ç‰©ä¹‹å…‰å…¥ä½“ï¼Œå¿ƒå¿µæ‰€åŠçš†ä¸ºæœ—ç…§ã€‚é™å®šå…‰çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +40%ã€‚'
  },

  // æš—çµæ ¹
  method_dark_abyss: {
    id: 'method_dark_abyss',
    name: 'å¿ƒæ³•Â·å¹½å½±å…¥æ¸Šå…¸',
    type: 'method',
    rarity: 'legendary',
    source: 'sect',
    price: 60000,
    qiSpeedBonus: 0.4,
    requirement: {
      type: 'rootAnyOf',
      ids: ['dark']
    },
    desc: 'æ”¶æ•›ä¸‡è±¡ä¹‹å…‰ï¼Œæ²‰å¿ƒå…¥æ¸Šã€‚é™å®šæš—çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +40%ã€‚'
  },

  /* ======================
   *  T3 çµæ€§ / æ„è¯†çµæ ¹ Â· å¿ƒæ³•
   * ====================== */

  // æ¢¦çµæ ¹
  method_dream_illusion: {
    id: 'method_dream_illusion',
    name: 'å¿ƒæ³•Â·æ¢¦è¡Œä¸‡æ™¯å½•',
    type: 'method',
    rarity: 'epic',
    source: 'sect',
    price: 35000,
    qiSpeedBonus: 0.33,
    requirement: {
      type: 'rootAnyOf',
      ids: ['dream']
    },
    desc: 'ç¡æ¢¦ä¸­è¸éåƒå±±ä¸‡æ°´ï¼Œäºè™šå¦„å¤„æ‚ŸçœŸã€‚é™å®šæ¢¦çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +33%ã€‚'
  },

  // çµçµæ ¹
  method_spirit_listen: {
    id: 'method_spirit_listen',
    name: 'å¿ƒæ³•Â·çµå¬ä¸‡æœºè¯€',
    type: 'method',
    rarity: 'epic',
    source: 'sect',
    price: 35000,
    qiSpeedBonus: 0.33,
    requirement: {
      type: 'rootAnyOf',
      ids: ['spirit']
    },
    desc: 'ä»¥çµè¯†è†å¬å¤©åœ°ç»†è¯­ã€‚é™å®šçµçµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +33%ã€‚'
  },

  // å¿ƒçµæ ¹
  method_heart_mirror: {
    id: 'method_heart_mirror',
    name: 'å¿ƒæ³•Â·ä¸åŠ¨å¿ƒé•œç¯‡',
    type: 'method',
    rarity: 'epic',
    source: 'sect',
    price: 35000,
    qiSpeedBonus: 0.33,
    requirement: {
      type: 'rootAnyOf',
      ids: ['heart']
    },
    desc: 'å¿ƒå¦‚æ˜é•œï¼Œç…§è§ä¸‡è±¡è€Œä¸ç•™ç—•ã€‚é™å®šå¿ƒçµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +33%ã€‚'
  },

  /* ======================
   *  T4 è‡ªç„¶æˆ˜æ–—çµæ ¹ Â· å¿ƒæ³•
   * ====================== */

  // å†°çµæ ¹
  method_ice_frostheart: {
    id: 'method_ice_frostheart',
    name: 'å¿ƒæ³•Â·å¯’é­„å‡éœœç« ',
    type: 'method',
    rarity: 'rare',
    source: 'sect',
    price: 20000,
    qiSpeedBonus: 0.28,
    requirement: {
      type: 'rootAnyOf',
      ids: ['ice']
    },
    desc: 'ä»¥å¿ƒç¥ä¸ºéœœé­„ï¼Œä»¤çœŸæ°”æ„ˆå‘æ¸…å†·å‡ç»ƒã€‚é™å®šå†°çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +28%ã€‚'
  },

  // é›·çµæ ¹
  method_thunder_tempest: {
    id: 'method_thunder_tempest',
    name: 'å¿ƒæ³•Â·é›·åŠ¨ä¹éœ„å·',
    type: 'method',
    rarity: 'rare',
    source: 'sect',
    price: 20000,
    qiSpeedBonus: 0.28,
    requirement: {
      type: 'rootAnyOf',
      ids: ['thunder']
    },
    desc: 'ä»¥é›·æ„æ·¬ç‚¼ç»è„‰ï¼Œä»¤çœŸæ°”å¥”æ¶Œå¦‚éœ¹é›³ã€‚é™å®šé›·çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +28%ã€‚'
  },

  /* ======================
   *  T5 äº”è¡Œå•çµæ ¹ Â· å¿ƒæ³•
   * ====================== */

  // é‡‘çµæ ¹
  method_metal_edge: {
    id: 'method_metal_edge',
    name: 'å¿ƒæ³•Â·é‡‘é”‹æ–©ç©ºè¯€',
    type: 'method',
    rarity: 'uncommon',
    source: 'sect',
    price: 12000,
    qiSpeedBonus: 0.22,
    requirement: {
      type: 'rootAnyOf',
      ids: ['metal']
    },
    desc: 'ä»¥é‡‘æ€§é”‹é”åˆ‡å‰Šæ‚è´¨ï¼Œä½¿çœŸæ°”ç²¾çº¯ã€‚é™å®šé‡‘çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +22%ã€‚'
  },

  // æœ¨çµæ ¹
  method_wood_vitality: {
    id: 'method_wood_vitality',
    name: 'å¿ƒæ³•Â·æœ¨ç”Ÿä¸‡è±¡ç¯‡',
    type: 'method',
    rarity: 'uncommon',
    source: 'sect',
    price: 12000,
    qiSpeedBonus: 0.22,
    requirement: {
      type: 'rootAnyOf',
      ids: ['wood']
    },
    desc: 'å€Ÿæœ¨æ€§ç”Ÿé•¿ä¹‹åŠ›ï¼Œä½¿çœŸæ°”æºæºä¸ç»ã€‚é™å®šæœ¨çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +22%ã€‚'
  },

  // æ°´çµæ ¹
  method_water_stream: {
    id: 'method_water_stream',
    name: 'å¿ƒæ³•Â·æ°´è½¬åƒæµæ³•',
    type: 'method',
    rarity: 'uncommon',
    source: 'sect',
    price: 12000,
    qiSpeedBonus: 0.22,
    requirement: {
      type: 'rootAnyOf',
      ids: ['water']
    },
    desc: 'ä»¥æ°´æ€§åœ†èï¼Œå¼•å¯¼çœŸæ°”åœ¨ä½“å†…å‘¨å¤©å¾ªç¯ã€‚é™å®šæ°´çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +22%ã€‚'
  },

  // ç«çµæ ¹
  method_fire_flame: {
    id: 'method_fire_flame',
    name: 'å¿ƒæ³•Â·èµ¤ç„°ç„šå¿ƒè¯€',
    type: 'method',
    rarity: 'uncommon',
    source: 'sect',
    price: 12000,
    qiSpeedBonus: 0.22,
    requirement: {
      type: 'rootAnyOf',
      ids: ['fire']
    },
    desc: 'ä»¥ç‚½çƒˆç«ç„°ç„šå°½æ‚å¿µï¼ŒçœŸæ°”éšä¹‹æ—ºç››ã€‚é™å®šç«çµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +22%ã€‚'
  },

  // åœŸçµæ ¹
  method_earth_barrier: {
    id: 'method_earth_barrier',
    name: 'å¿ƒæ³•Â·åšåœŸè½½å…ƒç¯‡',
    type: 'method',
    rarity: 'uncommon',
    source: 'sect',
    price: 12000,
    qiSpeedBonus: 0.22,
    requirement: {
      type: 'rootAnyOf',
      ids: ['earth']
    },
    desc: 'ä»¥åšåœŸæ‰¿è½½çœŸå…ƒï¼Œä½¿æ ¹åŸºæ„ˆå‘ç¨³å›ºã€‚é™å®šåœŸçµæ ¹è€…ä¿®ç‚¼ï¼Œä¿®ç‚¼é€Ÿåº¦ +22%ã€‚'
  },

  /* ======================
   *  é€šç”¨äº”è¡Œå¿ƒæ³•ï¼ˆå·²å­˜åœ¨ï¼‰
   * ====================== */

  // ä»»ä½•æ‹¥æœ‰ä»»æ„äº”è¡Œçµæ ¹è€…çš†å¯ä¿®
  method_five_cycle: {
    id: 'method_five_cycle',
    name: 'å¿ƒæ³•Â·äº”è¡Œå¾ªç¯è¯€',
    type: 'method',
    rarity: 'rare',
    source: 'sect',
    price: 8000,
    qiSpeedBonus: 0.2, // +20%
    requirement: {
      type: 'basicAny'
    },
    desc: 'è°ƒå’Œäº”è¡Œä¹‹æ°”ï¼Œä½¿å‘¨èº«çµåŠ›å¾ªç¯ä¸æ¯ã€‚éœ€å…·å¤‡ä»»æ„äº”è¡Œçµæ ¹ï¼Œä¿®ç‚¼é€Ÿåº¦ +20%ã€‚'
  },

  /* ======================
   *  ä»™æ³•ç§˜ç± Â· ç¤ºä¾‹
   * ====================== */

  // ä»™æ³•ç§˜ç±Â·æ¬¡å…ƒè£‚æ–©ï¼ˆç©ºé—´çµæ ¹ä¸“å±ï¼Œæˆ˜æ–—ä¸­ä¸€æ¬¡æ€§çˆ†å‘ï¼‰
  manual_dimensional_slash: {
    id: 'manual_dimensional_slash',
    name: 'ç§˜ç±Â·æ¬¡å…ƒè£‚æ–©',
    type: 'manual',
    rarity: 'mythic',
    source: 'sectAndDrop',
    price: 100000,
    requirement: {
      type: 'rootAnyOf',
      ids: ['space']
    },
    battle: {
      burstDimSlash: true
    },
    desc: 'é™å®šç©ºé—´çµæ ¹è€…ä¿®ç‚¼ã€‚æˆ˜æ–—ä¸­å¯åœ¨æŸä¸€å›åˆæ–©å‡ºæ¬¡å…ƒè£‚ç¼ï¼Œå¯¹æ•Œäººé€ æˆçº¦ 2000% çš„æ™®é€šæ”»å‡»ä¼¤å®³ã€‚'
  },

  /* ======================
   *  æ­¦æŠ€ï¼ˆåŸæœ‰ç¤ºä¾‹ä¿ç•™ï¼‰
   * ====================== */

  // æ­¦æŠ€ï¼šåŸºç¡€å¿«æ–©ï¼Œå¯åœ¨å¸‚é›†è´­ä¹°æˆ–æ‰è½ï¼Œå¢åŠ æ”»å‡»ä¸æš´å‡»ç‡
  tech_quick_strike: {
    id: 'tech_quick_strike',
    name: 'æ­¦æŠ€Â·é—ªé£å¿«æ–©',
    type: 'technique',
    rarity: 'uncommon',
    source: 'shopAndDrop',
    price: 2500,
    requirement: null,
    battle: {
      atkMul: 1.12,       // æ”»å‡» +12%
      critChance: 0.08    // é¢å¤– 8% æš´å‡»ç‡
    },
    desc: 'ç®€å•å®ç”¨çš„è¿‘èº«å¿«æ–©æ­¦æŠ€ï¼Œé€‚åˆå¤§å¤šæ•°è¿‘æˆ˜ä¿®å£«ã€‚è¢«åŠ¨æå‡æ”»å‡»ä¸å°‘é‡æš´å‡»ç‡ã€‚'
  },

  // æ­¦æŠ€ï¼šé“éª¨æŠ¤èº«ï¼Œå¯åœ¨å¸‚é›†è´­ä¹°æˆ–æ‰è½ï¼Œå¢åŠ ç”Ÿå‘½ä¸å‡ä¼¤
  tech_iron_body: {
    id: 'tech_iron_body',
    name: 'æ­¦æŠ€Â·é“éª¨æŠ¤èº«è¯€',
    type: 'technique',
    rarity: 'rare',
    source: 'shopAndDrop',
    price: 5000,
    requirement: null,
    battle: {
      hpMul: 1.18,            // ç”Ÿå‘½ +18%
      damageTakenMul: 0.92    // å—åˆ°ä¼¤å®³ -8%
    },
    desc: 'é”¤ç‚¼è‚‰èº«ä¸æ ¹éª¨ï¼Œä½¿ç­‹éª¨å¦‚é’¢é“èˆ¬åšéŸ§ã€‚è¢«åŠ¨æå‡ç”Ÿå‘½ä¸Šé™å¹¶é™ä½æ‰€å—ä¼¤å®³ã€‚'
  }
};
    
    /* ========== åŠŸæ³•çŠ¶æ€ ========== */

    let learnedSkillIds = [];   // å·²ä¹ å¾—åŠŸæ³•/ç§˜ç±/æ­¦æŠ€ id åˆ—è¡¨
    let equippedMethodId = null; // å½“å‰ä¸»ä¿®å¿ƒæ³• idï¼ˆæœ€å¤šä¸€ä¸ªï¼‰

    function getSkillById(id) {
      return ALL_SKILLS[id] || null;
    }

    function hasSkill(id) {
      return learnedSkillIds.includes(id);
    }

    function addSkill(id) {
      if (!ALL_SKILLS[id]) return false;
      if (!learnedSkillIds.includes(id)) {
        learnedSkillIds.push(id);
        return true;
      }
      return false;
    }

    function getSkillRarityMeta(skill) {
      return SKILL_RARITY_META[skill.rarity] || SKILL_RARITY_META.common;
    }

    function checkSkillRequirement(skill) {
      if (!skill.requirement) return true;
      if (!lingRoots || lingRoots.length === 0) return false;
      const req = skill.requirement;
      if (req.type === 'rootAnyOf') {
        return lingRoots.some(r => req.ids.includes(r.id));
      }
      if (req.type === 'basicAny') {
        return lingRoots.some(r => r.type === 'basic');
      }
      return true;
    }

    function getSkillRequirementText(skill) {
      if (!skill.requirement) return 'æ— ç‰¹æ®Šé™åˆ¶';
      const req = skill.requirement;
      if (req.type === 'rootAnyOf') {
        const names = req.ids.map(id => LING_ROOTS.find(r => r.id === id))
          .filter(Boolean)
          .map(r => r.name);
        return 'é™å®šçµæ ¹ï¼š' + (names.join(' / ') || 'ç‰¹å®šçµæ ¹');
      }
      if (req.type === 'basicAny') {
        return 'éœ€å…·å¤‡ä»»æ„äº”è¡Œçµæ ¹ï¼ˆé‡‘æœ¨æ°´ç«åœŸä¹‹ä¸€ï¼‰';
      }
      return 'ç‰¹æ®Šé™åˆ¶';
    }

    function getEquippedMethodSkill() {
      if (!equippedMethodId) return null;
      return ALL_SKILLS[equippedMethodId] || null;
    }

    function getMethodQiMult() {
      const m = getEquippedMethodSkill();
      if (!m || !m.qiSpeedBonus) return 1;
      return 1 + m.qiSpeedBonus;
    }

    /* ========== å¢ƒç•Œå®šä¹‰ï¼šå‡¡äºº + 11 ä¸ªå¤§å¢ƒç•Œï¼Œæ¯ä¸ªå‰ä¸­åå¤§åœ†æ»¡ ========= */

    const BIG_REALMS = ['å‡¡äºº','è¾Ÿè°·','ç‚¼ä½“','ç»ƒæ°”','ç­‘åŸº','é‡‘ä¸¹','å…ƒå©´','å‡ºçª','å¤§ä¹˜','æ¸¡åŠ«','åŒ–ç¥','ä»™ç­'];
    const REALM_SUFFIXES = ['å‰æœŸ','ä¸­æœŸ','åæœŸ','å¤§åœ†æ»¡'];
    const REALM_NAMES = [];
    const realmThresholds = [];

    REALM_NAMES[0] = 'å‡¡äºº';
    realmThresholds[0] = 0;

    for (let i = 1; i < BIG_REALMS.length; i++) {
      const base = Math.pow(10, i - 1) * 10; // 10,100,1000,10000,...
      const factors = [1, 2.5, 5, 9];        // 10/25/50/90...
      for (let j = 0; j < 4; j++) {
        const stageIndex = (i - 1) * 4 + j + 1;
        REALM_NAMES[stageIndex] = BIG_REALMS[i] + REALM_SUFFIXES[j];
        realmThresholds[stageIndex] = Math.floor(base * factors[j]);
      }
    }

    function getRealmNameFromStage(stage) {
      return REALM_NAMES[stage] || 'æœªçŸ¥å¢ƒç•Œ';
    }

    function getBigRealmIndex(stage) {
      if (stage <= 0) return -1;
      return Math.floor((stage - 1) / 4); // è¾Ÿè°·=0, ç‚¼ä½“=1,...
    }

    function isBigRoundStage(stage) {
      return stage > 0 && stage % 4 === 0;
    }

    const REALM_BIG_BONUSES = [
      { power: 1,  physique: 2,  agility: 1,  spirit: 1,  root: 2,  luck: 0 }, // è¾Ÿè°·
      { power: 2,  physique: 3,  agility: 2,  spirit: 1,  root: 2,  luck: 1 }, // ç‚¼ä½“
      { power: 3,  physique: 3,  agility: 2,  spirit: 2,  root: 2,  luck: 1 }, // ç»ƒæ°”
      { power: 4,  physique: 4,  agility: 3,  spirit: 3,  root: 3,  luck: 1 }, // ç­‘åŸº
      { power: 5,  physique: 5,  agility: 3,  spirit: 4,  root: 3,  luck: 2 }, // é‡‘ä¸¹
      { power: 6,  physique: 6,  agility: 4,  spirit: 5,  root: 4,  luck: 2 }, // å…ƒå©´
      { power: 7,  physique: 7,  agility: 4,  spirit: 6,  root: 4,  luck: 3 }, // å‡ºçª
      { power: 8,  physique: 8,  agility: 5,  spirit: 7,  root: 5,  luck: 3 }, // å¤§ä¹˜
      { power: 9,  physique: 9,  agility: 5,  spirit: 8,  root: 5,  luck: 4 }, // æ¸¡åŠ«
      { power: 10, physique:10, agility: 6,  spirit: 9,  root: 6,  luck: 4 }, // åŒ–ç¥
      { power: 12, physique:12, agility: 7,  spirit:10,  root: 7,  luck: 5 }  // ä»™ç­
    ];

    const REALM_BIG_QI_BONUS = [
      0.02, 0.04, 0.06, 0.09, 0.12, 0.16, 0.20, 0.25, 0.30, 0.40, 0.50
    ];

    // 50ã€500ã€5000ã€50000â€¦â€¦
    function getExpThresholdForBigRealmIndex(idx) {
      if (idx < 0) return 0;
      return 50 * Math.pow(10, idx);
    }

    function getCurrentExpRequirementForBreak(stage, experience) {
      if (!isBigRoundStage(stage)) return 0;
      const idx = getBigRealmIndex(stage);
      return getExpThresholdForBigRealmIndex(idx);
    }

    /* ========== éšæœº flavor å¥å­ ========= */
    const RANDOM_EVENTS = [
      'ä½ åœ¨å½’é€”ä¸­å¶ç„¶æ„Ÿåº”åˆ°è¿œå¤„æœ‰çµè„‰æ³¢åŠ¨ï¼Œä½†ä¿®ä¸ºå°šæµ…ï¼Œåªå¾—è®°åœ¨å¿ƒé‡Œã€‚',
      'ä¸€åªçµå…½ä»èº«æ—æ è¿‡ï¼Œä¼¼ä¹å¯¹ä½ çš„çµæ ¹å¤šçœ‹äº†ä¸€çœ¼ï¼Œéšå³æ¶ˆå¤±åœ¨æ—é—´ã€‚',
      'å¤©ç©ºç‚¸å“ä¸€å£°é—·é›·ï¼Œä½ éšçº¦æ„Ÿåˆ°ä½“å†…çœŸæ°”éšä¹‹éœ‡åŠ¨ã€‚',
      'ä½ è·¯è¿‡ä¸€åº§åºŸå¼ƒçŸ³äº­ï¼ŒçŸ³ç¢‘ä¸Šçš„å¤å­—åœ¨ä½™å…‰ä¸­ä¼¼ä¹é—ªçƒäº†ä¸€ç¬ã€‚',
      'è¿œå¤„æœ‰ä¿®å£«é£å‰‘è€Œè¿‡ï¼Œæº…èµ·çš„çµå…‰åœ¨ä½ çœ¼ä¸­ç•™ä¸‹çŸ­æš‚æ®‹å½±ã€‚',
      'ä¸€é˜µå¾®é£æ‹‚è¿‡ï¼Œä½ ææƒšé—´å¬è§æœ‰äººåœ¨è€³è¾¹ä½å£°å¿µè¯µå¤ç»ã€‚'
    ];
    function getRandomEventText() {
      const idx = Math.floor(Math.random() * RANDOM_EVENTS.length);
      return RANDOM_EVENTS[idx];
    }

    /* ========== å¤šå­˜æ¡£é…ç½® ========== */

    const NUM_SAVE_SLOTS = 3;
    const SAVE_SLOT_KEY_PREFIX = 'xiuxianIdleSave_v10_slot_';
    const ACTIVE_SLOT_KEY = 'xiuxianIdleCurrentSlot_v10';
    let activeSlot = 0;

    function getSlotKey(slot) {
      return SAVE_SLOT_KEY_PREFIX + String(slot);
    }

    function getSlotData(slot) {
      const raw = localStorage.getItem(getSlotKey(slot));
      if (!raw) return null;
      try {
        return JSON.parse(raw);
      } catch (e) {
        console.error('è¯»å–æ§½ä½å­˜æ¡£å¤±è´¥ï¼š', slot, e);
        return null;
      }
    }

    /* ========== æ ¸å¿ƒçŠ¶æ€ ========== */

    let gameStarted = false;
    let currentPage = 'cultivation';
    let autoBattle = false;

    let qi = 0;
    let qiPerSecond = 0.1;
    let qiPerClick = 1.0;
    let realmStage = 0;

    const baseStats = {
      power: 5, physique: 5, agility: 5,
      spirit: 5, root: 5,    luck: 5
    };
    let stats = { ...baseStats };

    let abilityPoints = 0;
    let spiritStones = 0;
    let experience = 0;

    // æ´åºœ & ä¸¹è¯å“è´¨ / æ•°é‡
    let caveCount = 0;
    let caveQuality = 1;
    let pillLevel = 1;
    let pillQuality = 1;

    // ä¿®ç‚¼åŸºç¡€
    let baseQiPerSecond = 0.1;
    let realmQpsBonus = 0;
    const caveQiPerBase = 0.2;
    let baseQiPerClick = 1.0;

    // ç©å®¶ & çµæ ¹
    let playerName = '';
    let lingRoots = [];
    let pendingWashLingRoots = [];
    let washConfirmEnabled = true;

    // å¼€å±€æŠ½çµæ ¹ä¸´æ—¶çŠ¶æ€
    let tempLingRoots = [];
    let rootRollUsed = false;
    let rootRerollLeft = 2;
    let rootWheelRunning = false;
    let rootWheelTimer = null;
    let washWheelRunning = false;
    let washWheelTimer = null;

    // ç¥Â·/ä»™å·
    let godTitleUnlocked = false;
    let immortalTitle = '';
    let immortalTitleUnlocked = false;

    // æ¸¸å†ï¼ˆæˆ˜æ–—ï¼‰çŠ¶æ€
    let currentBattle = null;
    let battleTimerId = null;
    const BATTLE_TURN_DELAY = 300;
    const MAX_TURNS = 20;
    let currentMapId = 'map_0';

    /* ========== å¸‚é›†å“è´¨æ–‡æœ¬ä¸ä»·æ ¼ ========== */

    const CAVE_QUALITY_NAMES = ['ç®€é™‹æ´åºœ', 'æ™®é€šæ´åºœ', 'ä¸Šå“æ´åºœ', 'æå“æ´åºœ', 'ä»™å“æ´åºœ'];
    const PILL_QUALITY_NAMES = ['å‡¡å“èšæ°”æ•£', 'æ™®é€šèšæ°”æ•£', 'ä¸Šå“èšæ°”æ•£', 'æå“èšæ°”æ•£', 'ä»™å“èšæ°”æ•£'];
    const MAX_CAVE_QUALITY = 5;
    const MAX_PILL_QUALITY = 5;

    const caveBaseStoneCost = 5;
    const pillBaseStoneCost = 4;
    const caveUpgradeBaseCost = 20;
    const pillUpgradeBaseCost = 15;
    const washPillBaseCost = 200; // æ´—é«“ä¸¹åŸºç¡€ä»·æ ¼ï¼ˆå½“å‰ä¸ºæµ‹è¯•ï¼š0 çµçŸ³ï¼‰

    function getCaveQualityName() {
      const idx = Math.min(caveQuality - 1, CAVE_QUALITY_NAMES.length - 1);
      return CAVE_QUALITY_NAMES[idx];
    }
    function getPillQualityName() {
      const idx = Math.min(pillQuality - 1, PILL_QUALITY_NAMES.length - 1);
      return PILL_QUALITY_NAMES[idx];
    }

    function getCaveBuyCost() {
      return Math.floor(caveBaseStoneCost * Math.pow(1.5, caveCount));
    }
    function getCaveUpgradeCost() {
      return Math.floor(caveUpgradeBaseCost * Math.pow(2, caveQuality - 1));
    }
    function getPillBuyCost() {
      return Math.floor(pillBaseStoneCost * Math.pow(1.4, pillLevel - 1));
    }
    function getPillUpgradeCost() {
      return Math.floor(pillUpgradeBaseCost * Math.pow(2, pillQuality - 1));
    }
    function getWashPillCost() {
      // æœªæ¥è‹¥è¦å¼€æ”¾æ­£å¼ä»·æ ¼ï¼Œå¯åœ¨æ­¤æ ¹æ®æ¬¡æ•°æˆ–å¢ƒç•ŒåŠ¨æ€è°ƒæ•´
      return washPillBaseCost;
    }

    function getCaveQps() {
      return caveCount * caveQiPerBase * (1 + 0.4 * (caveQuality - 1));
    }

    function recalcDerivedStats() {
      qiPerSecond =
        baseQiPerSecond +
        realmQpsBonus +
        getCaveQps();
      qiPerClick =
        baseQiPerClick +
        (pillLevel - 1) * (1 + 0.4 * (pillQuality - 1));
    }

    /* ========== å­˜æ¡£è¯»å†™é€»è¾‘ï¼ˆæ ¸å¿ƒæ•°æ® <-> JSONï¼‰ ========== */

    function loadFromData(data) {
      qi = typeof data.qi === 'number' ? data.qi : 0;
      baseQiPerSecond =
        typeof data.baseQiPerSecond === 'number' ? data.baseQiPerSecond : 0.1;
      baseQiPerClick =
        typeof data.baseQiPerClick === 'number' ? data.baseQiPerClick : 1.0;
      realmQpsBonus =
        typeof data.realmQpsBonus === 'number' ? data.realmQpsBonus : 0;

      caveCount =
        typeof data.caveCount === 'number' ? data.caveCount : 0;
      caveQuality =
        typeof data.caveQuality === 'number' ? data.caveQuality : 1;
      pillLevel =
        typeof data.pillLevel === 'number' ? data.pillLevel : 1;
      pillQuality =
        typeof data.pillQuality === 'number' ? data.pillQuality : 1;

      realmStage = (typeof data.realmStage === 'number') ? data.realmStage : 0;

      if (data.stats && typeof data.stats.power === 'number') {
        stats = { ...baseStats, ...data.stats };
      } else {
        stats = { ...baseStats };
      }

      abilityPoints = (typeof data.abilityPoints === 'number') ? data.abilityPoints : 0;
      spiritStones  = (typeof data.spiritStones === 'number') ? data.spiritStones : 0;
      experience    = (typeof data.experience === 'number') ? data.experience : 0;

      if (typeof data.playerName === 'string') playerName = data.playerName;
      else playerName = '';

      if (Array.isArray(data.lingRootIds)) {
        lingRoots = data.lingRootIds
          .map(id => LING_ROOTS.find(r => r.id === id))
          .filter(Boolean);
      } else {
        lingRoots = [];
      }

      currentMapId =
        typeof data.currentMapId === 'string' ? data.currentMapId : 'map_0';
      autoBattle = !!data.autoBattle;
      godTitleUnlocked = !!data.godTitleUnlocked;
      immortalTitle =
        typeof data.immortalTitle === 'string' ? data.immortalTitle : '';
      immortalTitleUnlocked = !!data.immortalTitleUnlocked;

      if (typeof data.washConfirmEnabled === 'boolean') {
        washConfirmEnabled = data.washConfirmEnabled;
      } else {
        washConfirmEnabled = true;
      }

      if (Array.isArray(data.learnedSkillIds)) {
        learnedSkillIds = data.learnedSkillIds.filter(id => !!ALL_SKILLS[id]);
      } else {
        learnedSkillIds = [];
      }
      if (typeof data.equippedMethodId === 'string' && ALL_SKILLS[data.equippedMethodId]) {
        equippedMethodId = data.equippedMethodId;
      } else {
        equippedMethodId = null;
      }

      recalcDerivedStats();
    }

    function saveGameToSlot(slot) {
      if (slot < 0 || slot >= NUM_SAVE_SLOTS) return;
      if (!gameStarted) return;
      const data = {
        qi,
        baseQiPerSecond,
        baseQiPerClick,
        realmQpsBonus,
        caveCount,
        caveQuality,
        pillLevel,
        pillQuality,
        realmStage,
        stats,
        abilityPoints,
        spiritStones,
        experience,
        playerName,
        lingRootIds: lingRoots.map(r => r.id),
        currentMapId,
        autoBattle,
        godTitleUnlocked,
        immortalTitle,
        immortalTitleUnlocked,
        learnedSkillIds,
        equippedMethodId,
        washConfirmEnabled,
        lastSaveTime: Date.now()
      };
      try {
        localStorage.setItem(getSlotKey(slot), JSON.stringify(data));
      } catch (e) {
        console.error('å­˜æ¡£å¤±è´¥ï¼š', e);
      }
    }

    function saveGame() {
      if (!gameStarted) return;
      saveGameToSlot(activeSlot);
      localStorage.setItem(ACTIVE_SLOT_KEY, String(activeSlot));
    }

    function loadGameFromSlot(slot) {
      const raw = localStorage.getItem(getSlotKey(slot));
      if (!raw) return false;
      try {
        const data = JSON.parse(raw);
        loadFromData(data);
        activeSlot = slot;
        localStorage.setItem(ACTIVE_SLOT_KEY, String(activeSlot));
        gameStarted = !!(playerName && playerName.trim());
        return true;
      } catch (e) {
        console.error('è¯»å–å­˜æ¡£å¤±è´¥ï¼š', e);
        return false;
      }
    }

    function loadGameAtStartup() {
      const storedSlot = localStorage.getItem(ACTIVE_SLOT_KEY);
      let slot = 0;
      if (storedSlot !== null) {
        const n = parseInt(storedSlot, 10);
        if (!isNaN(n) && n >= 0 && n < NUM_SAVE_SLOTS) slot = n;
      }
      activeSlot = slot;
      const ok = loadGameFromSlot(activeSlot);
      if (!ok) {
        // ç®€å•è¿ç§»ä¸€ä¸‹æ—§ç‰ˆæœ¬å•å­˜æ¡£ï¼ˆå¦‚æœæœ‰ï¼‰
        const legacy = localStorage.getItem('xiuxianIdleSave_v9');
        if (legacy) {
          try {
            const data = JSON.parse(legacy);
            loadFromData(data);
            activeSlot = 0;
            gameStarted = !!(playerName && playerName.trim());
            saveGameToSlot(0);
            localStorage.setItem(ACTIVE_SLOT_KEY, '0');
            localStorage.removeItem('xiuxianIdleSave_v9');
          } catch (e) {
            console.error('è¿ç§»æ—§å­˜æ¡£å¤±è´¥ï¼š', e);
          }
        }
      }
    }

    /* ========== DOM å¼•ç”¨ ========== */

    const qiSpan = document.getElementById('qi');
    const qpsSpan = document.getElementById('qps');
    const qpcSpan = document.getElementById('qpc');
    const realmSpan = document.getElementById('realm');

    const expMainSpan = document.getElementById('expMainSpan');
    const expReqSpan = document.getElementById('expReqSpan');
    const breakthroughBtn = document.getElementById('breakthroughBtn');

    const statPowerSpan = document.getElementById('statPower');
    const statPhysiqueSpan = document.getElementById('statPhysique');
    const statAgilitySpan = document.getElementById('statAgility');
    const statSpiritSpan = document.getElementById('statSpirit');
    const statRootSpan = document.getElementById('statRoot');
    const statLuckSpan = document.getElementById('statLuck');

    const abilityPointsSpan = document.getElementById('abilityPoints');
    const spiritStonesSpan = document.getElementById('spiritStonesSpan');
    const experienceSpan = document.getElementById('experienceSpan');
    const experienceBuffSpan = document.getElementById('experienceBuffSpan');

    const shopSpiritStonesSpan = document.getElementById('shopSpiritStones');

    const cultivateBtn = document.getElementById('cultivateBtn');
    const saveBtn = document.getElementById('saveBtn');
    const resetBtn = document.getElementById('resetBtn');
    const plusButtons = document.querySelectorAll('.btn-plus');

    const startScreen = document.getElementById('startScreen');
    const playerNameInput = document.getElementById('playerNameInput');
    const startGameBtn = document.getElementById('startGameBtn');
    const playerNameSpan = document.getElementById('playerName');
    const lingRootNameSpan = document.getElementById('lingRootName');
    const lingRootTableDiv = document.getElementById('lingRootTable');
    const lingRootBonusText = document.getElementById('lingRootBonusText');

    const rootDrawPanel = document.getElementById('rootDrawPanel');
    const rootPlayerNameSpan = document.getElementById('rootPlayerName');
    const rootWheel = document.getElementById('rootWheel');
    const rootWheelName = document.getElementById('rootWheelName');
    const rootResultNameSpan = document.getElementById('rootResultName');
    const rootResultTierSpan = document.getElementById('rootResultTier');
    const rootResultDescDiv = document.getElementById('rootResultDesc');
    const btnRootRoll = document.getElementById('btnRootRoll');
    const btnRootReroll = document.getElementById('btnRootReroll');
    const btnRootConfirm = document.getElementById('btnRootConfirm');
    const rootRerollLeftSpan = document.getElementById('rootRerollLeft');

    const pageCultivation = document.getElementById('pageCultivation');
    const pageBattle = document.getElementById('pageBattle');
    const pageShop = document.getElementById('pageShop');
    const pageSkills = document.getElementById('pageSkills');
    const pageSect = document.getElementById('pageSect');
    const navItems = document.querySelectorAll('.nav-item');

    const caveCostSpan = document.getElementById('caveCost');
    const caveCountSpan = document.getElementById('caveCount');
    const caveQualitySpan = document.getElementById('caveQualitySpan');
    const caveUpgradeCostSpan = document.getElementById('caveUpgradeCost');
    const caveQpsSpan = document.getElementById('caveQpsSpan');

    const pillCostSpan = document.getElementById('pillCost');
    const pillLevelSpan = document.getElementById('pillLevel');
    const pillQualitySpan = document.getElementById('pillQualitySpan');
    const pillUpgradeCostSpan = document.getElementById('pillUpgradeCost');
    const washPillCostSpan = document.getElementById('washPillCost');

    const buyCaveBtn = document.getElementById('buyCaveBtn');
    const upgradeCaveBtn = document.getElementById('upgradeCaveBtn');
    const buyPillBtn = document.getElementById('buyPillBtn');
    const upgradePillBtn = document.getElementById('upgradePillBtn');
    const buyWashPillBtn = document.getElementById('buyWashPillBtn');

    const shopSkillList = document.getElementById('shopSkillList');

    // æ¸¸å†
    const playerBattleStatsDiv = document.getElementById('playerBattleStats');
    const mapSelect = document.getElementById('mapSelect');
    const startBattleBtn = document.getElementById('startBattleBtn');
    const battleResultDiv = document.getElementById('battleResult');
       const battleLogDiv = document.getElementById('battleLog');
    const autoBattleToggle = document.getElementById('autoBattleToggle');

    const battleResultOverlay = document.getElementById('battleResultOverlay');
    const resultTitle = document.getElementById('resultTitle');
    const resultSummary = document.getElementById('resultSummary');
    const resultDrops = document.getElementById('resultDrops');
    const resultExtra = document.getElementById('resultExtra');
    const randomEventDiv = document.getElementById('randomEvent');

    const washRootOverlay = document.getElementById('washRootOverlay');
    const washOldRootNameSpan = document.getElementById('washOldRootName');
    const washRootWheel = document.getElementById('washRootWheel');
    const washRootWheelName = document.getElementById('washRootWheelName');
    const washRootResultNameSpan = document.getElementById('washRootResultName');
    const washRootResultTierSpan = document.getElementById('washRootResultTier');
    const washRootResultDescDiv = document.getElementById('washRootResultDesc');
    const btnWashRootRoll = document.getElementById('btnWashRootRoll');
    const btnWashKeepOld = document.getElementById('btnWashKeepOld');
    const btnWashReplace = document.getElementById('btnWashReplace');
    const btnWashClose = document.getElementById('btnWashClose');
    const washConfirmToggle = document.getElementById('washConfirmToggle');
    const closeResultBtn = document.getElementById('closeResultBtn');

    // åŠŸæ³•é¡µ DOM
    const activeMethodInfo = document.getElementById('activeMethodInfo');
    const knownSkillsList = document.getElementById('knownSkillsList');
    const sectOfferList = document.getElementById('sectOfferList');

    // å­˜æ¡£ UI DOM
    const activeSlotSpan = document.getElementById('activeSlotSpan');
    const saveSlotList = document.getElementById('saveSlotList');

    /* ========== çµæ ¹ UI ========== */

    function updateLingRootUI() {
      lingRootNameSpan.textContent = getLingRootDisplayName();
      applyLingRootColor(lingRootNameSpan, lingRoots);

      const meta = getLingRootTierMeta();
      const qiBonus      = ((meta.qiMult - 1) * 100).toFixed(0);
      const abilityBonus = ((meta.abilityMult - 1) * 100).toFixed(0);
      const eventBonus   = ((meta.eventMult - 1) * 100).toFixed(0);

      function fmt(v) {
        const n = Number(v);
        if (n === 0) return '+0%';
        return (n > 0 ? '+' : '') + n + '%';
      }
      lingRootBonusText.textContent =
        `ä¿®ç‚¼é€Ÿåº¦ ${fmt(qiBonus)} Â· èƒ½åŠ›ç‚¹ ${fmt(abilityBonus)} Â· å¥‡é‡æƒé‡ ${fmt(eventBonus)}`;

      lingRootTableDiv.innerHTML = '';
      if (!lingRoots || lingRoots.length === 0) {
        lingRootTableDiv.textContent = 'å°šæœªè§‰é†’çµæ ¹ã€‚';
        return;
      }

      // åŒäº”è¡Œçµæ ¹ï¼šåˆå¹¶å±•ç¤º
      if (lingRoots.length === 2 && lingRoots.every(r => r.type === 'basic')) {
        const [r1, r2] = lingRoots;
        const rel = getDualBasicRelation(lingRoots);
        const cfg1 = LING_ROOTS_CONFIG && LING_ROOTS_CONFIG[r1.id];
        const cfg2 = LING_ROOTS_CONFIG && LING_ROOTS_CONFIG[r2.id];

        const row1 = document.createElement('div');
        row1.className = 'ling-root-row';
        const comboLabel = rel && rel.comboName ? `${rel.label} Â· ${rel.comboName}` : rel.label;
        row1.innerHTML = `<span>${r1.short}${r2.short}åŒçµæ ¹</span><span>å±‚çº§ï¼š${comboLabel}</span>`;
        lingRootTableDiv.appendChild(row1);

        const row2 = document.createElement('div');
        row2.className = 'ling-root-row';
        row2.innerHTML =
          `<span>èƒ½åŠ›å€¾å‘ï¼š</span><span>${r1.name} ä¸ ${r2.name} å¹¶å­˜ã€‚${rel.descExtra || ''}</span>`;
        lingRootTableDiv.appendChild(row2);

        if (cfg1 || cfg2) {
          const row3 = document.createElement('div');
          row3.className = 'ling-root-row';
          const parts = [];
          if (cfg1) parts.push(`${cfg1.name}ï¼š${cfg1.foundationRole}`);
          if (cfg2) parts.push(`${cfg2.name}ï¼š${cfg2.foundationRole}`);
          row3.innerHTML = `<span>åŸºç¡€å®šä½ï¼š</span><span>${parts.join('ï¼›')}</span>`;
          lingRootTableDiv.appendChild(row3);
        }
      } else {
        // å•çµæ ¹ / ç¨€æœ‰çµæ ¹
        lingRoots.forEach(r => {
          const row1 = document.createElement('div');
          row1.className = 'ling-root-row';
          row1.innerHTML =
            `<span>${r.name}</span><span>å±‚çº§ï¼š${r.tierGroup} Â· ç±»å‹ï¼š${r.type === 'special' ? 'ç¨€æœ‰' : 'äº”è¡Œ'}</span>`;
          lingRootTableDiv.appendChild(row1);

          const row2 = document.createElement('div');
          row2.className = 'ling-root-row';
          const cfg = LING_ROOTS_CONFIG && LING_ROOTS_CONFIG[r.id];
          if (cfg) {
            const detailText =
              `${cfg.foundationRole}ã€‚æˆ˜æ–—ï¼š${cfg.battle}ï¼›ç”Ÿäº§/ç³»ç»Ÿï¼š${cfg.production}`;
            row2.innerHTML = `<span>èƒ½åŠ›å€¾å‘ï¼š</span><span>${detailText}</span>`;
          } else {
            row2.innerHTML = `<span>èƒ½åŠ›å€¾å‘ï¼š</span><span>${r.desc}</span>`;
          }
          lingRootTableDiv.appendChild(row2);
        });
      }

      const extra = document.createElement('div');
      extra.className = 'ling-root-row';
      const meta2 = getLingRootTierMeta();
      const qi2 = ((meta2.qiMult - 1) * 100).toFixed(0);
      const ab2 = ((meta2.abilityMult - 1) * 100).toFixed(0);
      const ev2 = ((meta2.eventMult - 1) * 100).toFixed(0);
      extra.innerHTML =
        `<span>ç³»ç»ŸåŠ æˆï¼š</span><span>${meta2.label}ï¼ˆä¿®ç‚¼é€Ÿåº¦ ${fmt(qi2)} Â· èƒ½åŠ›ç‚¹ ${fmt(ab2)} Â· å¥‡é‡æƒé‡ ${fmt(ev2)}ï¼‰</span>`;
      lingRootTableDiv.appendChild(extra);
    }

    /* ========== åŠŸæ³•é¡µ / å®—é—¨ / å•†åº—æŠ€èƒ½ UI ========== */

    function updateSkillsUI() {
      if (!activeMethodInfo || !knownSkillsList) return;

      if (!gameStarted) {
        activeMethodInfo.textContent = 'å°šæœªå¼€å§‹ä¿®ç‚¼ã€‚';
        knownSkillsList.textContent = 'æš‚æ— ä»»ä½•åŠŸæ³•æˆ–æ­¦æŠ€ã€‚';
        return;
      }

      const method = getEquippedMethodSkill();
      if (!method) {
        activeMethodInfo.textContent =
          'å½“å‰æœªä¸»ä¿®ä»»ä½•å¿ƒæ³•ã€‚å¯å‰å¾€ã€Œå®—é—¨ã€å­¦ä¹ ä¸çµæ ¹å¥‘åˆçš„åŠŸæ³•ï¼Œä»¥è¿›ä¸€æ­¥æå‡ä¿®ç‚¼é€Ÿåº¦ã€‚';
      } else {
        const rar = getSkillRarityMeta(method);
        const bonusPercent = method.qiSpeedBonus ? Math.round(method.qiSpeedBonus * 100) : 0;
        activeMethodInfo.innerHTML =
          `å½“å‰ä¸»ä¿®ï¼š<span class="skill-name ${rar.className}">${method.name}ï¼ˆ${rar.label}Â·å¿ƒæ³•ï¼‰</span> Â· ` +
          `æ•ˆæœï¼šä¿®ç‚¼é€Ÿåº¦ +${bonusPercent}%ã€‚`;
      }

      if (!learnedSkillIds.length) {
        knownSkillsList.textContent = 'ä½ å°šæœªæŒæ¡ä»»ä½•åŠŸæ³•æˆ–æ­¦æŠ€ã€‚';
        return;
      }

      knownSkillsList.innerHTML = '';
      learnedSkillIds.forEach(id => {
        const skill = getSkillById(id);
        if (!skill) return;
        const rar = getSkillRarityMeta(skill);
        const wrapper = document.createElement('div');
        wrapper.className = 'skill-item';

        const left = document.createElement('div');
        left.className = 'skill-left';
        const typeLabel =
          skill.type === 'method' ? 'å¿ƒæ³•'
          : skill.type === 'manual' ? 'ç§˜ç±'
          : 'æ­¦æŠ€';
        left.innerHTML =
          `<div class="skill-name ${rar.className}">${skill.name}ï¼ˆ${rar.label}Â·${typeLabel}ï¼‰</div>` +
          `<div>${skill.desc || ''}</div>`;

        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.flexDirection = 'column';
        right.style.alignItems = 'flex-end';
        right.style.gap = '4px';

        const reqText = getSkillRequirementText(skill);
        const spanReq = document.createElement('div');
        spanReq.style.fontSize = '11px';
        spanReq.style.color = '#9aa0c6';
        spanReq.textContent = reqText;
        right.appendChild(spanReq);

        if (skill.type === 'method') {
          const btn = document.createElement('button');
          btn.className = 'btn-small';
          if (equippedMethodId === skill.id) {
            btn.textContent = 'å·²ä¸»ä¿®';
            btn.disabled = true;
          } else {
            btn.textContent = 'è®¾ä¸ºä¸»ä¿®';
            btn.addEventListener('click', () => {
              equippedMethodId = skill.id;
              updateUI();
              saveGame();
            });
          }
          right.appendChild(btn);
        }

        wrapper.appendChild(left);
        wrapper.appendChild(right);
        knownSkillsList.appendChild(wrapper);
      });
    }

    function refreshSectOfferingsUI() {
      if (!sectOfferList) return;
      sectOfferList.innerHTML = '';
      if (!gameStarted) {
        sectOfferList.textContent = 'è¯·å…ˆè¸å…¥ä¿®ä»™å¹¶å–ä¸€ä¸ªé“å·ã€‚';
        return;
      }

      const offerSkills = Object.values(ALL_SKILLS).filter(skill =>
        skill.source === 'sect' || skill.source === 'sectAndDrop'
      );

      if (!offerSkills.length) {
        sectOfferList.textContent = 'å®—é—¨æš‚æœªå¼€æ”¾ä¼ æ‰¿ã€‚';
        return;
      }

      offerSkills.forEach(skill => {
        const rar = getSkillRarityMeta(skill);
        const wrapper = document.createElement('div');
        wrapper.className = 'skill-item';

        const left = document.createElement('div');
        left.className = 'skill-left';
        const typeLabel =
          skill.type === 'method' ? 'å¿ƒæ³•'
          : skill.type === 'manual' ? 'ç§˜ç±'
          : 'æ­¦æŠ€';
        left.innerHTML =
          `<div class="skill-name ${rar.className}">${skill.name}ï¼ˆ${rar.label}Â·${typeLabel}ï¼‰</div>` +
          `<div>${skill.desc || ''}</div>` +
          `<div style="font-size:11px;color:#b6c1ff;">ä»·æ ¼ï¼š${skill.price} çµçŸ³</div>` +
          `<div style="font-size:11px;color:#9aa0c6;">${getSkillRequirementText(skill)}</div>`;

        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.flexDirection = 'column';
        right.style.alignItems = 'flex-end';
        right.style.gap = '4px';

        const btn = document.createElement('button');
        btn.className = 'btn-small';

        const alreadyLearned = hasSkill(skill.id);
        const reqOK = checkSkillRequirement(skill);
        if (alreadyLearned) {
          btn.textContent = 'å·²æŒæ¡';
          btn.disabled = true;
        } else if (!reqOK) {
          btn.textContent = 'çµæ ¹ä¸ç¬¦';
          btn.disabled = true;
        } else {
          btn.textContent = 'å­¦ä¹ ';
          btn.disabled = spiritStones < skill.price;
          btn.addEventListener('click', () => {
            if (spiritStones < skill.price) {
              alert('çµçŸ³ä¸è¶³ï¼Œæ— æ³•å­¦ä¹ æ­¤åŠŸæ³•ã€‚');
              return;
            }
            if (!checkSkillRequirement(skill)) {
              alert('ä½ çš„çµæ ¹ä¸æ­¤åŠŸæ³•ä¸ç¬¦ï¼Œæš‚æ— æ³•ä¿®ç‚¼ã€‚');
              return;
            }
            spiritStones -= skill.price;
            addSkill(skill.id);
            if (skill.type === 'method' && !equippedMethodId) {
              equippedMethodId = skill.id;
            }
            updateUI();
            refreshSectOfferingsUI();
            saveGame();
          });
        }
        right.appendChild(btn);

        wrapper.appendChild(left);
        wrapper.appendChild(right);
        sectOfferList.appendChild(wrapper);
      });
    }

    function refreshShopSkillsUI() {
      if (!shopSkillList) return;
      shopSkillList.innerHTML = '';
      if (!gameStarted) {
        shopSkillList.textContent = 'è¯·å…ˆå¼€å§‹ä¿®ç‚¼ã€‚';
        return;
      }

      const skills = Object.values(ALL_SKILLS).filter(skill =>
        skill.source === 'shop' || skill.source === 'shopAndDrop'
      );
      if (!skills.length) {
        shopSkillList.textContent = 'å¸‚é›†ä¸­æš‚æœªæœ‰å¯è´­ä¹°çš„æ­¦æŠ€å·è½´ã€‚';
        return;
      }

      skills.forEach(skill => {
        const rar = getSkillRarityMeta(skill);
        const wrapper = document.createElement('div');
        wrapper.className = 'skill-item';

        const left = document.createElement('div');
        left.className = 'skill-left';
        left.innerHTML =
          `<div class="skill-name ${rar.className}">${skill.name}ï¼ˆ${rar.label}Â·æ­¦æŠ€ï¼‰</div>` +
          `<div>${skill.desc || ''}</div>` +
          `<div style="font-size:11px;color:#b6c1ff;">ä»·æ ¼ï¼š${skill.price} çµçŸ³</div>`;

        const right = document.createElement('div');
        right.style.display = 'flex';
        right.style.flexDirection = 'column';
        right.style.alignItems = 'flex-end';
        right.style.gap = '4px';

        const btn = document.createElement('button');
        btn.className = 'btn-small';

        if (hasSkill(skill.id)) {
          btn.textContent = 'å·²æŒæ¡';
          btn.disabled = true;
        } else {
          btn.textContent = 'è´­ä¹°';
          btn.disabled = spiritStones < skill.price;
          btn.addEventListener('click', () => {
            if (spiritStones < skill.price) {
              alert('çµçŸ³ä¸è¶³ï¼Œæ— æ³•è´­ä¹°æ­¤æ­¦æŠ€å·è½´ã€‚');
              return;
            }
            spiritStones -= skill.price;
            addSkill(skill.id);
            updateUI();
            refreshShopSkillsUI();
            saveGame();
          });
        }
        right.appendChild(btn);

        wrapper.appendChild(left);
        wrapper.appendChild(right);
        shopSkillList.appendChild(wrapper);
      });
    }

    /* ========== å­˜æ¡£ç®¡ç† UI ========== */

    function updateSaveSlotUI() {
      if (!activeSlotSpan || !saveSlotList) return;
      activeSlotSpan.textContent = (activeSlot + 1) + 'å·';

      saveSlotList.innerHTML = '';
      for (let i = 0; i < NUM_SAVE_SLOTS; i++) {
        const data = getSlotData(i);
        const row = document.createElement('div');
        row.className = 'upgrade';

        const infoDiv = document.createElement('div');
        infoDiv.className = 'upgrade-info';

        if (data && data.playerName) {
          const name = data.playerName || 'æ— åæ•£ä¿®';
          const realmName = getRealmNameFromStage(
            typeof data.realmStage === 'number' ? data.realmStage : 0
          );
          const timeStr = data.lastSaveTime
            ? new Date(data.lastSaveTime).toLocaleString()
            : 'æœªçŸ¥æ—¶é—´';
          infoDiv.innerHTML =
            `æ§½ä½ ${i + 1}ï¼š<strong>${name}</strong>ï¼ˆ${realmName}ï¼‰<br>` +
            `<span style="font-size:11px;color:#9aa0c6;">ä¸Šæ¬¡ä¿å­˜ï¼š${timeStr}</span>`;
        } else {
          infoDiv.innerHTML =
            `æ§½ä½ ${i + 1}ï¼š<span style="color:#9aa0c6;">ç©ºå­˜æ¡£</span>`;
        }

        row.appendChild(infoDiv);

        const btnWrap = document.createElement('div');
        btnWrap.style.display = 'flex';
        btnWrap.style.flexDirection = 'column';
        btnWrap.style.gap = '4px';

        const loadBtn = document.createElement('button');
        loadBtn.className = 'btn-small';
        loadBtn.textContent = 'è¯»å–';
        loadBtn.disabled = !data;
        loadBtn.addEventListener('click', () => {
          if (!data) return;
          if (currentBattle || battleTimerId) {
            alert('æˆ˜æ–—ä¸­æ— æ³•åˆ‡æ¢å­˜æ¡£ï¼Œè¯·å…ˆç»“æŸå½“å‰æ¸¸å†ã€‚');
            return;
          }
          // è¯»å–æ—¶æš‚ä¸å¼ºåˆ¶è¯¢é—®ä¿å­˜ï¼Œä¿æŒåŸè¡Œä¸º
          const ok = loadGameFromSlot(i);
          if (ok) {
            startScreen.style.display = gameStarted ? 'none' : 'flex';
            updateUI();
          }
        });

        const saveBtn = document.createElement('button');
        saveBtn.className = 'btn-small';
        saveBtn.textContent = (i === activeSlot ? 'ä¿å­˜' : 'è¦†ç›–');
        saveBtn.addEventListener('click', () => {
          if (!gameStarted) {
            alert('å½“å‰æ²¡æœ‰æ­£åœ¨ä¿®ç‚¼çš„è§’è‰²ï¼Œæ— æ³•ä¿å­˜ã€‚');
            return;
          }
          activeSlot = i;
          saveGame();
          updateSaveSlotUI();
        });

        const clearBtn = document.createElement('button');
        clearBtn.className = 'btn-small';
        clearBtn.textContent = 'æ¸…ç©º';
        clearBtn.addEventListener('click', () => {
          if (!confirm(`ç¡®å®šæ¸…ç©º ${i + 1} å·å­˜æ¡£å—ï¼Ÿ`)) return;
          localStorage.removeItem(getSlotKey(i));
          // ä¸è‡ªåŠ¨é‡ç½®å½“å‰æ¸¸æˆï¼Œåªæ˜¯æ¸…æ‰è¯¥æ§½æ•°æ®
          updateSaveSlotUI();
        });

        const selectBtn = document.createElement('button');
        selectBtn.className = 'btn-small';
        selectBtn.textContent = 'é€‰æ‹©';
        selectBtn.addEventListener('click', () => {
          if (currentBattle || battleTimerId) {
            alert('æˆ˜æ–—ä¸­æ— æ³•åˆ‡æ¢å­˜æ¡£æ§½ï¼Œè¯·å…ˆç»“æŸå½“å‰æ¸¸å†ã€‚');
            return;
          }
          if (i === activeSlot) {
            alert('è¯¥æ§½ä½å·²ç»æ˜¯å½“å‰å­˜æ¡£æ§½ã€‚');
            return;
          }

          if (gameStarted) {
            const wantSave = confirm(
              'åœ¨åˆ‡æ¢åˆ°æ–°çš„å­˜æ¡£æ§½å‰ï¼Œè¦å…ˆå°†å½“å‰è¿›åº¦ä¿å­˜åˆ°å½“å‰æ§½ä½å—ï¼Ÿ\n\nâ€œç¡®å®šâ€=ä¿å­˜ååˆ‡æ¢ï¼Œâ€œå–æ¶ˆâ€=ç›´æ¥åˆ‡æ¢ã€‚'
            );
            if (wantSave) {
              saveGame();
            }
          }

          const slotData = getSlotData(i);
          activeSlot = i;
          localStorage.setItem(ACTIVE_SLOT_KEY, String(activeSlot));

          if (slotData) {
            // è¯¥æ§½å·²æœ‰å­˜æ¡£ï¼šç›´æ¥è½½å…¥
            loadGameFromSlot(i);
            startScreen.style.display = gameStarted ? 'none' : 'flex';
            updateUI();
          } else {
            // è¯¥æ§½ä¸ºç©ºï¼šä»¥æ­¤æ§½ä¸ºå½“å‰æ§½ï¼Œå¹¶é‡ç½®ä¸ºå…¨æ–°å¼€å§‹
            resetGame();
            startScreen.style.display = 'flex';
            updateSaveSlotUI();
            updateUI();
          }
        });

        btnWrap.appendChild(loadBtn);
        btnWrap.appendChild(saveBtn);
        btnWrap.appendChild(clearBtn);
        btnWrap.appendChild(selectBtn);

        row.appendChild(btnWrap);
        saveSlotList.appendChild(row);
      }
    }

    /* ========== å¢ƒç•ŒåŠ æˆï¼šæ¯é˜¶æ®µ/æ¯å¤§å¢ƒç•ŒåŠ æˆ ========= */

    function applyStageBonus(stage) {
      if (stage <= 0) return;
      const bigIdx = getBigRealmIndex(stage);
      const incBase = 1 + Math.floor(bigIdx / 2);

      stats.power    += incBase;
      stats.physique += incBase + 1;
      stats.agility  += incBase;
      stats.spirit   += incBase;
      stats.root     += incBase + 1;
      stats.luck     += Math.max(1, Math.floor(incBase / 2));

      if (stage % 4 === 1) {
        if (bigIdx === 9 && !godTitleUnlocked) {
          godTitleUnlocked = true;
          alert('ä½ å·²è¸å…¥ã€ŒåŒ–ç¥ã€å¢ƒç•Œï¼Œè·å¾—ç§°å·ï¼šç¥Â·ï¼ˆæ˜¾ç¤ºåœ¨é“å·å‰ï¼‰ã€‚');
        }
        if (bigIdx === 10 && !immortalTitleUnlocked) {
          immortalTitleUnlocked = true;
          const name = prompt(
            'æ­å–œä½ æˆåŠŸæ™‹çº§ã€Œä»™ç­ã€ï¼è¯·ä¸ºè‡ªå·±å–ä¸€ä¸ªä»™å·ï¼ˆå°†æ˜¾ç¤ºåœ¨é“å·å‰ï¼‰ï¼š',
            'æŸæŸä¸Šä»™'
          );
          if (name && name.trim()) {
            immortalTitle = name.trim();
          }
        }
      }
    }

    function applyRealmBonus(stage) {
      if (stage <= 0) return;
      const idx = getBigRealmIndex(stage);
      if (idx < 0 || idx >= REALM_BIG_BONUSES.length) return;
      const bonus = REALM_BIG_BONUSES[idx];
      stats.power    += bonus.power;
      stats.physique += bonus.physique;
      stats.agility  += bonus.agility;
      stats.spirit   += bonus.spirit;
      stats.root     += bonus.root;
      stats.luck     += bonus.luck;
      realmQpsBonus  += REALM_BIG_QI_BONUS[idx] || 0;
      recalcDerivedStats();
    }

    /* ========== è‡ªåŠ¨çªç ´ & æ‰‹åŠ¨çªç ´ ========= */

    function checkBreakthrough() {
      let upgraded = false;
      while (realmStage < realmThresholds.length - 1) {
        const nextStage = realmStage + 1;
        if (qi < realmThresholds[nextStage]) break;
        if (isBigRoundStage(realmStage)) break;
        realmStage = nextStage;
        applyStageBonus(realmStage);
        if (isBigRoundStage(realmStage)) {
          applyRealmBonus(realmStage);
        }
        upgraded = true;
      }
      if (upgraded) recalcDerivedStats();
    }

    function canManualBreakthrough() {
      if (!gameStarted) return false;
      if (!isBigRoundStage(realmStage)) return false;
      if (realmStage >= realmThresholds.length - 1) return false;

      const expReq = getCurrentExpRequirementForBreak(realmStage, experience);
      if (experience < expReq) return false;

      const nextStage = realmStage + 1;
      if (qi < realmThresholds[nextStage]) return false;

      return true;
    }

    function doManualBreakthrough() {
      if (!canManualBreakthrough()) return;

      const bigIdxCurrent = getBigRealmIndex(realmStage);
      if (bigIdxCurrent >= 3) {
        const failChance = (bigIdxCurrent - 2) / 100;
        if (Math.random() < failChance) {
          const lost = Math.floor(qi * 0.1);
          qi = Math.max(0, qi - lost);
          alert(`çªç ´å¤±è´¥ï¼çœŸæ°”éœ‡è¡ï¼ŒæŸå¤± ${lost} ç‚¹çœŸæ°”ã€‚å¯è°ƒæ•´å¿ƒå¢ƒåå†å°è¯•ã€‚`);
          updateUI();
          return;
        }
      }

      const oldName = getRealmNameFromStage(realmStage);
      realmStage = realmStage + 1;
      applyStageBonus(realmStage);
      if (isBigRoundStage(realmStage)) {
        applyRealmBonus(realmStage);
      }
      checkBreakthrough();
      recalcDerivedStats();
      const newName = getRealmNameFromStage(realmStage);
      updateUI();
      alert(`ä½ ä»ã€Œ${oldName}ã€çªç ´åˆ°äº†ã€Œ${newName}ã€ï¼`);
    }

    /* ========== èƒ½åŠ›ç‚¹æ‰è½ï¼ˆéš¾åº¦æé«˜ï¼‰ ========== */

    function rollAbilityPoint(source) {
      const base = (source === 'auto') ? 0.004 : 0.018;
      const meta = getLingRootTierMeta();
      const lingMult = meta.abilityMult;
      const luckDiff = stats.luck - baseStats.luck;
      const luckMult = 1 + luckDiff * 0.03;
      let chance = base * lingMult * luckMult;
      if (chance > 0.8) chance = 0.8;
      if (Math.random() < chance) {
        abilityPoints++;
      }
    }

    /* ========== æ¸¸å†å±æ€§ ========= */

    function getPlayerBattleStats() {
      const expBuff = 1 + Math.min(experience * 0.002, 0.5);
      const maxHp = 90 + stats.physique * 9 + stats.root * 6;
      const mpMax = 50 + stats.spirit * 5;
      const atk = (10 + stats.power * 2) * expBuff;
      let dodge = 0.05 + stats.agility * 0.006;
      if (dodge > 0.45) dodge = 0.45;
      const spd = 100 + stats.agility * 2;

      return {
        maxHp: Math.floor(maxHp),
        hp: Math.floor(maxHp),
        mpMax: Math.floor(mpMax),
        mp: Math.floor(mpMax),
        atk: Math.floor(atk),
        dodge,
        spd,
        phys: stats.physique,
        root: stats.root
      };
    }

    function updateBattleStatsUI() {
      if (!playerBattleStatsDiv) return;
      if (!gameStarted) {
        playerBattleStatsDiv.textContent = 'å°šæœªè¸å…¥ä¿®è¡Œï¼Œå±æ€§æœªçŸ¥ã€‚';
        return;
      }
      const base = getPlayerBattleStats();
      playerBattleStatsDiv.textContent =
        `ä½ çš„å±æ€§ï¼šç”Ÿå‘½ ${base.maxHp} Â· æ”»å‡» ${base.atk} Â· è“é‡ ${base.mpMax} Â· ` +
        `é—ªé¿ ${(base.dodge * 100).toFixed(1)}% Â· é€Ÿåº¦ ${base.spd}`;
    }

    // æŠ€èƒ½æˆ˜æ–—è¢«åŠ¨æ•ˆæœèšåˆ
    function getSkillBattleEffects() {
      const eff = {
        atkMul: 1,
        hpMul: 1,
        speedMul: 1,
        dodgeBonus: 0,
        damageTakenMul: 1,
        enemySpeedMul: 1,
        lifeSteal: 0,
        regenPerTurn: 0,
        critChance: 0,
        critMul: 1.5,
        extraTurnChance: 0,
        burstDimSlash: false
      };

      learnedSkillIds.forEach(id => {
        const s = getSkillById(id);
        if (!s || !s.battle) return;
        const b = s.battle;
        if (b.atkMul) eff.atkMul *= b.atkMul;
        if (b.hpMul) eff.hpMul *= b.hpMul;
        if (b.speedMul) eff.speedMul *= b.speedMul;
        if (b.dodgeBonus) eff.dodgeBonus += b.dodgeBonus;
        if (b.damageTakenMul) eff.damageTakenMul *= b.damageTakenMul;
        if (b.enemySpeedMul) eff.enemySpeedMul *= b.enemySpeedMul;
        if (b.lifeSteal) eff.lifeSteal += b.lifeSteal;
        if (b.regenPerTurn) eff.regenPerTurn += b.regenPerTurn;
        if (b.critChance) eff.critChance += b.critChance;
        if (b.critMul) eff.critMul = Math.max(eff.critMul, b.critMul);
        if (b.extraTurnChance) eff.extraTurnChance += b.extraTurnChance;
        if (b.burstDimSlash) eff.burstDimSlash = true;
      });

      if (eff.critChance > 0.5) eff.critChance = 0.5;
      if (eff.dodgeBonus > 0.3) eff.dodgeBonus = 0.3;
      return eff;
    }

    // çµæ ¹æˆ˜æ–—è¢«åŠ¨ï¼ˆç›®å‰ç•™ç©ºï¼Œå°†æ¥å¯ä»¥å åŠ ï¼‰
    function getLingRootBattleEffects() {
      const baseEff = {
        atkMul: 1,
        hpMul: 1,
        speedMul: 1,
        dodgeBonus: 0,
        damageTakenMul: 1,
        enemySpeedMul: 1,
        lifeSteal: 0,
        regenPerTurn: 0,
        critChance: 0,
        critMul: 1.5,
        extraTurnChance: 0,
        burstDimSlash: false
      };
      const skillEff = getSkillBattleEffects();
      baseEff.atkMul *= skillEff.atkMul;
      baseEff.hpMul *= skillEff.hpMul;
      baseEff.speedMul *= skillEff.speedMul;
      baseEff.dodgeBonus += skillEff.dodgeBonus;
      baseEff.damageTakenMul *= skillEff.damageTakenMul;
      baseEff.enemySpeedMul *= skillEff.enemySpeedMul;
      baseEff.lifeSteal += skillEff.lifeSteal;
      baseEff.regenPerTurn += skillEff.regenPerTurn;
      baseEff.critChance += skillEff.critChance;
      baseEff.critMul = Math.max(baseEff.critMul, skillEff.critMul);
      baseEff.extraTurnChance += skillEff.extraTurnChance;
      baseEff.burstDimSlash = skillEff.burstDimSlash;
      return baseEff;
    }

    /* ========== ä¼¤å®³å…¬å¼ ========= */

    function calcDamage(attackerAtk, defenderPhysique, defenderRoot) {
      const defScore = defenderPhysique * 0.6 + defenderRoot * 0.4;
      let mitigate = 1 / (1 + defScore * 0.018);
      if (mitigate < 0.35) mitigate = 0.35;
      if (mitigate > 1) mitigate = 1;
      const variance = 0.9 + Math.random() * 0.2;
      const raw = attackerAtk * variance;
      return Math.max(1, Math.floor(raw * mitigate));
    }

    /* ========== åœ°å›¾ ========= */

    let MAPS = [];

    function generateMaps() {
      MAPS = [];
      for (let s = 0; s < REALM_NAMES.length; s++) {
        const stageName = REALM_NAMES[s];
        let rewardMult = 0.6 + s * 0.12;
        if (rewardMult > 6) rewardMult = 6;
        MAPS.push({
          id: 'map_' + s,
          name: `${stageName} Â· æ¸¸å†ä¹‹åœ°`,
          enemyStage: s,
          rewardMult
        });
      }
    }

    function initMaps() {
      mapSelect.innerHTML = '';
      MAPS.forEach(m => {
        const opt = document.createElement('option');
        opt.value = m.id;
        opt.textContent = m.name;
        mapSelect.appendChild(opt);
      });
      mapSelect.value = currentMapId;
    }

    function getCurrentMap() {
      return MAPS.find(m => m.id === currentMapId) || MAPS[0];
    }

    /* ========== æ•Œäººç”Ÿæˆ ========= */

    function generateRandomEnemy(targetStage) {
      const enemyStage = (typeof targetStage === 'number') ? targetStage : realmStage;
      const stageDiff = enemyStage - realmStage;
      const stageFactor = Math.max(0.4, 1 + stageDiff * 0.3);

      const basePower = Math.max(1, stats.power * stageFactor);
      const basePhys  = Math.max(1, stats.physique * stageFactor);
      const baseRoot  = Math.max(1, stats.root * stageFactor);
      const baseAgi   = Math.max(1, stats.agility * stageFactor);

      function randAround(v) {
        const factor = 1 + (Math.random() * 2 - 1) * 0.25;
        return Math.max(1, Math.round(v * factor));
      }

      const ePower = randAround(basePower);
      const ePhys  = randAround(basePhys);
      const eRoot  = randAround(baseRoot);
      const eAgi   = randAround(baseAgi);

      const maxHp = 80 + ePhys * 9 + eRoot * 6;
      const atk   = 9 + ePower * 2;
      let dodge   = 0.04 + eAgi * 0.005;
      if (dodge > 0.35) dodge = 0.35;
      const spd   = 100 + eAgi * 2;

      const realmName = getRealmNameFromStage(enemyStage);
      const namePool = ['æ¸¸è¡ä¿®å£«', 'è¯•ç‚¼å¹»å½±', 'æµæµªæ•£ä¿®', 'åŒé—¨å‰‘ä¿®', 'å¤é˜µæ®‹å½±'];
      const n = namePool[Math.floor(Math.random() * namePool.length)];

      return {
        name: `${realmName}Â·${n}`,
        maxHp: Math.floor(maxHp),
        hp: Math.floor(maxHp),
        atk: Math.floor(atk),
        dodge,
        spd,
        physique: ePhys,
        root: eRoot
      };
    }

    /* ========== é‡ç½®ï¼ˆåªæ¸…ç©ºå½“å‰æ§½ä½ï¼‰ ========== */

    function resetGame() {
      qi = 0;
      baseQiPerSecond = 0.1;
      baseQiPerClick = 1.0;
      realmQpsBonus = 0;
      recalcDerivedStats();

      caveCount = 0;
      caveQuality = 1;
      pillLevel = 1;
      pillQuality = 1;
      realmStage = 0;
      stats = { ...baseStats };
      abilityPoints = 0;
      spiritStones = 0;
      experience = 0;
      playerName = '';
      lingRoots = [];
      currentBattle = null;
      currentMapId = 'map_0';
      gameStarted = false;
      autoBattle = false;
      godTitleUnlocked = false;
      immortalTitle = '';
      immortalTitleUnlocked = false;
      learnedSkillIds = [];
      equippedMethodId = null;

      localStorage.removeItem(getSlotKey(activeSlot));

      playerNameInput.value = '';
      battleLogDiv.innerHTML = '';
      battleResultDiv.textContent = '';
      autoBattleToggle.checked = false;

      startScreen.style.display = 'flex';
    }

    /* ========== UI åˆ‡æ¢ & æ›´æ–° ========== */

    function switchPage(page) {
      currentPage = page;
      pageCultivation.style.display = (page === 'cultivation') ? 'block' : 'none';
      pageBattle.style.display      = (page === 'battle')      ? 'block' : 'none';
      pageShop.style.display        = (page === 'shop')        ? 'block' : 'none';
      pageSkills.style.display      = (page === 'skills')      ? 'block' : 'none';
      pageSect.style.display        = (page === 'sect')        ? 'block' : 'none';

      navItems.forEach(item => {
        item.classList.toggle('active', item.dataset.page === page);
      });

      if (page === 'battle') {
        maybeStartAutoBattle();
      }
      if (page === 'skills') {
        updateSkillsUI();
      }
      if (page === 'sect') {
        refreshSectOfferingsUI();
      }
      if (page === 'shop') {
        refreshShopSkillsUI();
      }
    }

    function updateUI() {
      const meta = getLingRootTierMeta();
      const methodMult = getMethodQiMult();

      const effectiveQps = qiPerSecond * meta.qiMult * methodMult;
      const effectiveQpc = qiPerClick * meta.qiMult * methodMult;

      qiSpan.textContent  = qi.toFixed(1);
      qpsSpan.textContent = effectiveQps.toFixed(1);
      qpcSpan.textContent = effectiveQpc.toFixed(1);

      realmSpan.textContent = getRealmNameFromStage(realmStage);

      expMainSpan.textContent = experience;
      const expReq = getCurrentExpRequirementForBreak(realmStage, experience);
      expReqSpan.textContent = expReq > 0 ? expReq : 'â€”';

      const dmgBuffPercent = Math.min(experience * 0.2, 50);
      experienceSpan.textContent     = experience;
      experienceBuffSpan.textContent = dmgBuffPercent.toFixed(1);

      statPowerSpan.textContent    = stats.power;
      statPhysiqueSpan.textContent = stats.physique;
      statAgilitySpan.textContent  = stats.agility;
      statSpiritSpan.textContent   = stats.spirit;
      statRootSpan.textContent     = stats.root;
      statLuckSpan.textContent     = stats.luck;

      abilityPointsSpan.textContent    = abilityPoints;
      spiritStonesSpan.textContent     = spiritStones;
      shopSpiritStonesSpan.textContent = spiritStones;

      const caveBuyCost = getCaveBuyCost();
      const caveUpCost  = getCaveUpgradeCost();
      caveCostSpan.textContent = caveBuyCost;
      caveCountSpan.textContent = caveCount;
      caveQualitySpan.textContent = getCaveQualityName();
      caveUpgradeCostSpan.textContent = caveUpCost;
      caveQpsSpan.textContent = getCaveQps().toFixed(2);

      const pillBuyCost = getPillBuyCost();
      const pillUpCost  = getPillUpgradeCost();
      pillCostSpan.textContent = pillBuyCost;
      pillLevelSpan.textContent = pillLevel;
      pillQualitySpan.textContent = getPillQualityName();
      pillUpgradeCostSpan.textContent = pillUpCost;
      const washCost = getWashPillCost();
      if (washPillCostSpan) washPillCostSpan.textContent = washCost;

      plusButtons.forEach(btn => {
        btn.disabled = abilityPoints <= 0 || !gameStarted;
      });

      buyCaveBtn.disabled =
        !gameStarted || spiritStones < caveBuyCost;
      upgradeCaveBtn.disabled =
        !gameStarted || caveQuality >= MAX_CAVE_QUALITY || spiritStones < caveUpCost;

      buyPillBtn.disabled =
        !gameStarted || spiritStones < pillBuyCost;
      upgradePillBtn.disabled =
        !gameStarted || pillQuality >= MAX_PILL_QUALITY || spiritStones < pillUpCost;
      if (buyWashPillBtn) {
        buyWashPillBtn.disabled =
          !gameStarted || !lingRoots.length || spiritStones < washCost;
      }

      breakthroughBtn.disabled = !canManualBreakthrough();

      let displayName = playerName || 'æœªå‘½å';
      if (godTitleUnlocked) displayName = 'ç¥Â·' + displayName;
      if (immortalTitle) displayName = immortalTitle + 'Â·' + displayName;
      playerNameSpan.textContent = displayName;

      autoBattleToggle.checked = autoBattle;

      updateLingRootUI();
      updateBattleStatsUI();
      updateSaveSlotUI();

      if (currentPage === 'skills') {
        updateSkillsUI();
      }
      if (currentPage === 'sect') {
        refreshSectOfferingsUI();
      }
      if (currentPage === 'shop') {
        refreshShopSkillsUI();
      }
    }

    /* ========== æ¸¸å†æ—¥å¿— & ç»“ç®— ========= */

    function appendBattleLog(msg) {
      const line = document.createElement('div');
      line.textContent = msg;
      battleLogDiv.appendChild(line);
      battleLogDiv.scrollTop = battleLogDiv.scrollHeight;
    }

    function handleRandomEncounter(outcome, battleData) {
      const meta = getLingRootTierMeta();
      const baseChance = 0.25;
      let chance = baseChance * meta.eventMult;
      if (chance > 0.9) chance = 0.9;

      let triggered = false;
      let text = '';
      let extraQi = 0;
      let extraStones = 0;
      let extraAbility = 0;
      let breakthrough = false;

      if (Math.random() >= chance) {
        text = 'è¿™æ¬¡æ¸¸å†é£å¹³æµªé™ï¼Œæœªè§¦å‘æ˜æ˜¾å¥‡é‡ã€‚ ' + getRandomEventText();
        return { triggered, text, extraQi, extraStones, extraAbility, breakthrough };
      }

      triggered = true;

      const options = ['stoneBurst', 'qiSurge', 'realmInsight', 'bigRealmFreeBreak', 'caveDiscover'];
      let type = options[Math.floor(Math.random() * options.length)];

      const isBigRound = isBigRoundStage(realmStage)
        && realmStage < REALM_NAMES.length - 1;

      if (!isBigRound && type === 'bigRealmFreeBreak') {
        type = 'qiSurge';
      }

      if (type === 'stoneBurst') {
        const idx = Math.max(0, getBigRealmIndex(realmStage));
        extraStones = 1 + Math.floor(Math.random() * (2 + idx));
        spiritStones += extraStones;
        text = `å¥‡é‡ï¼šä½ åœ¨å½’é€”ä¸­æ„å¤–å‘ç°ä¸€å°å †çµçŸ³ï¼Œé¢å¤–è·å¾— ${extraStones} æšçµçŸ³ã€‚`;
      } else if (type === 'qiSurge') {
        const extraQiBase = 10 + qiPerSecond * 20;
        extraQi = Math.floor(extraQiBase);
        gainQi(extraQi, 'event');
        text = `å¥‡é‡ï¼šä¸ç ´ä¸ç«‹ï¼Œä½ åœ¨å›æƒ³è¿™æ¬¡æ¸¸å†æ—¶æ°”æœºé¼“è¡ï¼Œä¸€å£æ°”æå‡äº† ${extraQi} ç‚¹çœŸæ°”ã€‚`;
      } else if (type === 'realmInsight') {
        const nextStage = realmStage + 1;
        if (nextStage < realmThresholds.length && qi >= realmThresholds[nextStage]) {
          realmStage++;
          applyStageBonus(realmStage);
          if (isBigRoundStage(realmStage)) {
            applyRealmBonus(realmStage);
          }
          checkBreakthrough();
          breakthrough = true;
          text = `å¥‡é‡ï¼šæ­¤æ¬¡æ¸¸å†è®©ä½ æ„Ÿæ‚Ÿè®¸å¤šï¼Œå¢ƒç•Œæ‚„ç„¶çªç ´è‡³ã€Œ${getRealmNameFromStage(realmStage)}ã€ã€‚`;
        } else {
          extraAbility = 1;
          abilityPoints += 1;
          text = 'å¥‡é‡ï¼šä½ å¯¹æˆ˜æ–—ç»†èŠ‚å›å‘³è‰¯ä¹…ï¼Œå¿ƒæœ‰æ‰€æ‚Ÿï¼Œé¢å¤–è·å¾— 1 ç‚¹èƒ½åŠ›ç‚¹ã€‚';
        }
      } else if (type === 'bigRealmFreeBreak') {
        const nextStage = realmStage + 1;
        if (isBigRound && nextStage < realmThresholds.length && qi >= realmThresholds[nextStage]) {
          realmStage++;
          applyStageBonus(realmStage);
          if (isBigRoundStage(realmStage)) {
            applyRealmBonus(realmStage);
          }
          checkBreakthrough();
          breakthrough = true;
          text = `å¥‡é‡ï¼šä½ æœ¬å°±å¤„äºå¤§åœ†æ»¡è¾¹ç¼˜ï¼Œåœ¨è¿™æ¬¡æ¸¸å†èƒœåˆ©åï¼Œæ— éœ€é¢å¤–å†ç»ƒä¾¿ç›´æ¥çªç ´è‡³ã€Œ${getRealmNameFromStage(realmStage)}ã€ã€‚`;
        } else {
          text = 'å¥‡é‡ï¼šä½ éšçº¦æ„Ÿåˆ°ç“¶é¢ˆæ¾åŠ¨ï¼Œå´ä»å·®ä¸€æ­¥ç«å€™ã€‚';
        }
      } else if (type === 'caveDiscover') {
        if (caveQuality < MAX_CAVE_QUALITY) {
          caveQuality++;
          recalcDerivedStats();
          text = `å¥‡é‡ï¼šä½ åœ¨å±±é—´å‘ç°ä¸€å¤„çµæ°”æ„ˆå‘æµ‘åšçš„æ´çªŸï¼Œå°†åŸæœ‰æ´åºœæ®æ­¤æ”¹é€ ï¼Œæ´åºœå“è´¨æå‡ä¸ºã€Œ${getCaveQualityName()}ã€ï¼Œè‡ªåŠ¨ä¿®ç‚¼é€Ÿåº¦å¤§å¹…æå‡ã€‚`;
        } else {
          extraStones = 2 + Math.floor(Math.random() * 3);
          spiritStones += extraStones;
          text = `å¥‡é‡ï¼šä½ æ‰“ç®—æ”¹é€ æ´åºœï¼Œå´å‘ç°å·²éš¾ä»¥æ›´è¿›ä¸€æ­¥ï¼Œåªå¾—æŠŠå¿ƒæ€è½¬ä¸ºæœåˆ®é™„è¿‘èµ„æºï¼Œé¢å¤–è·å¾— ${extraStones} æšçµçŸ³ã€‚`;
        }
      }

      text += ' ' + getRandomEventText();
      return { triggered, text, extraQi, extraStones, extraAbility, breakthrough };
    }

    function tryDropSkillFromBattle() {
      if (!gameStarted) return null;
      const candidates = Object.values(ALL_SKILLS).filter(skill =>
        (skill.source === 'drop' || skill.source === 'sectAndDrop' || skill.source === 'shopAndDrop') &&
        !hasSkill(skill.id)
      );
      if (!candidates.length) return null;

      const meta = getLingRootTierMeta();
      const baseChance = 0.02;
      const luckBonus = stats.luck * 0.0015;
      let chance = (baseChance + luckBonus) * meta.eventMult;
      if (chance > 0.2) chance = 0.2;

      if (Math.random() >= chance) return null;

      const weights = candidates.map(skill => {
        switch (skill.rarity) {
          case 'common': return 6;
          case 'uncommon': return 4;
          case 'rare': return 3;
          case 'epic': return 2;
          case 'legendary': return 1.2;
          case 'mythic': return 0.5;
          default: return 1;
        }
      });
      let total = weights.reduce((a, b) => a + b, 0);
      let r = Math.random() * total;
      let idx = 0;
      for (let i = 0; i < candidates.length; i++) {
        r -= weights[i];
        if (r <= 0) { idx = i; break; }
      }
      const skill = candidates[idx];
      addSkill(skill.id);
      return skill;
    }

    function showBattleResultOverlay(outcome, battleData, rewards, eventInfo, droppedSkill) {
      resultTitle.textContent =
        outcome === 'win' ? 'æ¸¸å†èƒœåˆ©'
        : outcome === 'lose' ? 'æ¸¸å†å—æŒ«'
        : 'ä¸åˆ†èƒœè´Ÿ';

      const enemyName = battleData.enemy.name;
      const summaryLines = [];
      if (outcome === 'win') {
        summaryLines.push(`ä½ æˆåŠŸå‡»è´¥äº†ã€Œ${enemyName}ã€ã€‚`);
      } else if (outcome === 'lose') {
        summaryLines.push(`ä½ è¢«ã€Œ${enemyName}ã€å‡»é€€ï¼Œåªå¾—æš‚ä¸”æ’¤ç¦»ã€‚`);
      } else {
        summaryLines.push(`ä½ ä¸ã€Œ${enemyName}ã€é–æˆ˜å¤šå›åˆï¼Œæœ€ç»ˆæš‚ä¸”ç½¢æ‰‹ã€‚`);
      }
      summaryLines.push(`æœ¬æ¬¡æ¸¸å†å…±è¿›è¡Œäº† ${battleData.turn - 1} ä¸ªå›åˆã€‚`);
      resultSummary.textContent = summaryLines.join(' ');

      let dropsText = [
        rewards.qiReward > 0     ? `çœŸæ°”ï¼š+${rewards.qiReward}` : null,
        rewards.expGain > 0      ? `å†ç»ƒå€¼ï¼š+${rewards.expGain}ï¼ˆæ€»å†ç»ƒï¼š${experience}ï¼‰` : `å†ç»ƒå€¼ï¼šæ— å¢é•¿`,
        rewards.abilityGain > 0  ? `èƒ½åŠ›ç‚¹ï¼š+${rewards.abilityGain}ï¼ˆå¯ç”¨ï¼š${abilityPoints}ï¼‰` : null,
        rewards.stoneReward > 0  ? `çµçŸ³ï¼š+${rewards.stoneReward}ï¼ˆæ€»è®¡ï¼š${spiritStones}ï¼‰` : null
      ].filter(Boolean).join(' Â· ');
      if (droppedSkill) {
        dropsText += (dropsText ? ' Â· ' : '') + `æ–°å¾—åŠŸæ³•ï¼š${droppedSkill.name}`;
      }
      resultDrops.textContent = dropsText || 'æœ¬æ¬¡æœªè·å¾—æ˜¾è‘—æˆ˜åˆ©å“ã€‚';

      let extra = '';
      if (isBigRoundStage(realmStage)) {
        const req = getCurrentExpRequirementForBreak(realmStage, experience);
        extra = `å½“å‰å¢ƒç•Œï¼š${getRealmNameFromStage(realmStage)}ï¼›çªç ´åˆ°ä¸‹ä¸€å¤§å¢ƒç•Œæ‰€éœ€å†ç»ƒå€¼çº¦ä¸º ${req}ã€‚`;
      } else {
        extra = `å½“å‰å¢ƒç•Œï¼š${getRealmNameFromStage(realmStage)}ã€‚`;
      }
      resultExtra.textContent = extra;

      randomEventDiv.textContent = eventInfo.text || 'æœ¬æ¬¡æœªè§¦å‘å¥‡é‡ã€‚';

      battleResultOverlay.style.display = 'flex';
    }

    function endBattle(outcome) {
      if (!currentBattle) return;
      clearInterval(battleTimerId);
      battleTimerId = null;
      startBattleBtn.disabled = false;

      const battleData = currentBattle;
      currentBattle = null;

      const map = battleData.map;
      const rewardMult = map.rewardMult;

      let qiReward = 0;
      let stoneReward = 0;

      const idx = Math.max(0, getBigRealmIndex(realmStage));

      if (outcome === 'win') {
        const baseQi = 6 + idx * 3;
        qiReward = Math.round((baseQi + Math.random() * (5 + idx * 3)) * rewardMult);
        stoneReward = (Math.random() < 0.7)
          ? 1 + Math.floor(Math.random() * (1 + idx + 1))
          : 0;
      } else if (outcome === 'lose') {
        qiReward = Math.round((2 + idx) * rewardMult);
      } else {
        qiReward = Math.round((3 + idx) * rewardMult);
      }

      let expGain = 0;
      if (outcome === 'win') {
        expGain = Math.max(1, Math.round((3 + idx * 2) * rewardMult));
      } else if (outcome === 'lose') {
        expGain = Math.max(1, Math.round((1 + idx) * rewardMult));
      } else {
        expGain = Math.max(1, Math.round((2 + idx) * rewardMult));
      }
      experience += expGain;

      const abilityBefore = battleData.abilityBefore;
      const expBefore = battleData.expBefore;

      if (qiReward > 0) gainQi(qiReward, 'battle');
      if (stoneReward > 0) spiritStones += stoneReward;

      const eventInfo = handleRandomEncounter(outcome, battleData);
      const droppedSkill = tryDropSkillFromBattle();
      if (droppedSkill) {
        eventInfo.text = (eventInfo.text || '') + ` æ­¤å¤–ï¼Œä½ åœ¨æˆ˜åœºä¸Šæ„å¤–è·å¾—äº†ä¸€å·ã€Š${droppedSkill.name}ã€‹ã€‚`;
      }

      const abilityGain = abilityPoints - abilityBefore;
      const totalExpGain = experience - expBefore;
      const totalStoneReward = stoneReward + (eventInfo.extraStones || 0);

      updateUI();

      const shouldShowOverlay = !autoBattle;
      if (shouldShowOverlay) {
        showBattleResultOverlay(outcome, battleData, {
          qiReward,
          stoneReward: totalStoneReward,
          expGain: totalExpGain,
          abilityGain
        }, eventInfo, droppedSkill);
      } else {
        let autoText =
          `ä¸€åœºæ¸¸å†å·²ç»“æŸï¼ˆ${outcome === 'win' ? 'èƒœåˆ©' : outcome === 'lose' ? 'å—æŒ«' : 'å¹³å±€'}ï¼‰ï¼Œå¥–åŠ±å·²è‡ªåŠ¨ç»“ç®—ã€‚`;
        if (droppedSkill) {
          autoText += ` è·å¾—æ–°åŠŸæ³•ï¼šã€Š${droppedSkill.name}ã€‹ã€‚`;
        }
        battleResultDiv.textContent = autoText;
        saveGame();
      }

      // è‡ªåŠ¨æˆ˜æ–—ï¼šç¨ä½œåœé¡¿åè‡ªåŠ¨å¼€ä¸‹ä¸€å±€
      if (autoBattle) {
        setTimeout(() => {
          maybeStartAutoBattle();
        }, 800);
      }
    }

    function runBattleTurn() {
      if (!currentBattle) {
        clearInterval(battleTimerId);
        battleTimerId = null;
        return;
      }
      const b = currentBattle;
      const eff = b.effects;

      if (b.player.hp <= 0 || b.enemy.hp <= 0 || b.turn > MAX_TURNS) {
        let outcome = 'draw';
        if (b.player.hp > 0 && b.enemy.hp <= 0) outcome = 'win';
        else if (b.enemy.hp > 0 && b.player.hp <= 0) outcome = 'lose';
        endBattle(outcome);
        return;
      }

      if (b.currentActor === 'player') {
        if (!b.skillState) b.skillState = {};

        // å›åˆå¼€å§‹ï¼šå°‘é‡æ¢å¤
        if (eff.regenPerTurn > 0) {
          const oldHp = b.player.hp;
          b.player.hp = Math.min(b.player.maxHp, b.player.hp + eff.regenPerTurn);
          if (b.player.hp > oldHp) {
            appendBattleLog(`å›åˆ ${b.turn}ï¼šä½ çš„ä½“é­„æ¢å¤äº† ${b.player.hp - oldHp} ç‚¹ç”Ÿå‘½ã€‚`);
          }
        }

        // æ¬¡å…ƒè£‚æ–©ï¼ˆå¦‚æœå­˜åœ¨ï¼‰
        if (eff.burstDimSlash && !b.skillState.dimSlashUsed) {
          b.skillState.dimSlashUsed = true;
          const baseDmg = calcDamage(b.player.atk, b.enemy.physique, b.enemy.root);
          const skillDmg = Math.floor(baseDmg * 20); // çº¦ 2000% ä¼¤å®³
          b.enemy.hp = Math.max(0, b.enemy.hp - skillDmg);
          appendBattleLog(
            `å›åˆ ${b.turn}ï¼šä½ æ–½å±•ã€Œæ¬¡å…ƒè£‚æ–©ã€ï¼Œæ–©å‡ºç»´åº¦è£‚ç—•ï¼Œå¯¹ã€Œ${b.enemy.name}ã€é€ æˆ ${skillDmg} ç‚¹æ¯ç­æ€§ä¼¤å®³ï¼`
          );
          if (b.enemy.hp <= 0) {
            appendBattleLog(`ã€Œ${b.enemy.name}ã€åœ¨æ¬¡å…ƒè£‚ç¼ä¸­å´©è§£ã€‚`);
          }
          b.currentActor = 'enemy';
          b.turn++;
          return;
        }

        // æ™®é€šæ”»å‡»æµç¨‹
        const effectiveAtk = b.player.atk;
        let dmg = calcDamage(effectiveAtk, b.enemy.physique, b.enemy.root);

        let crit = false;
        if (eff.critChance > 0 && Math.random() < eff.critChance) {
          crit = true;
          dmg = Math.floor(dmg * eff.critMul);
        }

        const dodgeRoll = Math.random();
        if (dodgeRoll < b.enemy.dodge) {
          appendBattleLog(`å›åˆ ${b.turn}ï¼šä½ å‡ºæ‰‹æ”»å‡»ï¼Œä½†ã€Œ${b.enemy.name}ã€é—ªé¿äº†è¿™ä¸€å‡»ã€‚`);
        } else {
          b.enemy.hp = Math.max(0, b.enemy.hp - dmg);
          let text = `å›åˆ ${b.turn}ï¼šä½ æ”»å‡»ã€Œ${b.enemy.name}ã€ï¼Œé€ æˆ ${dmg} ç‚¹ä¼¤å®³ï¼ˆå¯¹æ–¹å‰©ä½™ ${b.enemy.hp}ï¼‰ã€‚`;
          if (crit) text += 'ã€æš´å‡»ã€‘';
          appendBattleLog(text);

          if (eff.lifeSteal > 0 && dmg > 0) {
            const heal = Math.floor(dmg * eff.lifeSteal);
            if (heal > 0) {
              const oldHp = b.player.hp;
              b.player.hp = Math.min(b.player.maxHp, b.player.hp + heal);
              if (b.player.hp > oldHp) {
                appendBattleLog(`ä½ ä»ä¼¤åŠ¿ä¸­æ±²å–äº† ${b.player.hp - oldHp} ç‚¹ç”Ÿå‘½ã€‚`);
              }
            }
          }
        }

        let changeTurn = true;
        if (b.enemy.hp > 0 && eff.extraTurnChance > 0 && Math.random() < eff.extraTurnChance) {
          appendBattleLog('æ—¶é—´ä¼¼ä¹ä¸ºä½ åœæ»äº†ä¸€ç¬ï¼Œä½ æŠ“ä½ç©ºéš™å†æ¬¡å‡ºæ‰‹ï¼');
          changeTurn = false;
        }

        b.currentActor = changeTurn ? 'enemy' : 'player';
        b.turn++;
      } else {
        const dodgeRoll = Math.random();
        if (dodgeRoll < b.player.dodge) {
          appendBattleLog(`å›åˆ ${b.turn}ï¼šã€Œ${b.enemy.name}ã€æ”»å‡»ä½ ï¼Œä½†ä½ èº«å½¢ä¸€é—ªèº²äº†è¿‡å»ã€‚`);
        } else {
          let dmg = calcDamage(b.enemy.atk, b.player.physDef, b.player.rootDef);
          dmg = Math.floor(dmg * eff.damageTakenMul);
          if (dmg < 1) dmg = 1;
          b.player.hp = Math.max(0, b.player.hp - dmg);
          appendBattleLog(
            `å›åˆ ${b.turn}ï¼šã€Œ${b.enemy.name}ã€æ”»å‡»ä½ ï¼Œé€ æˆ ${dmg} ç‚¹ä¼¤å®³ï¼ˆä½ å‰©ä½™ ${b.player.hp}ï¼‰ã€‚`
          );
        }
        b.currentActor = 'player';
        b.turn++;
      }
    }

    function startBattle() {
      if (!gameStarted) {
        battleResultDiv.textContent = 'è¯·å…ˆè¸å…¥ä¿®ä»™å¹¶å®Œæˆå‘½åã€‚';
        return;
      }
      if (battleTimerId || currentBattle) return;

      const pBase = getPlayerBattleStats();
      const eff = getLingRootBattleEffects();
      const map = getCurrentMap();
      const enemyBase = generateRandomEnemy(map.enemyStage);

      const maxHp = Math.floor(pBase.maxHp * eff.hpMul);
      const atk   = Math.floor(pBase.atk * eff.atkMul);
      const dodge = Math.min(0.5, pBase.dodge + eff.dodgeBonus);
      const spd   = Math.floor(pBase.spd * eff.speedMul);

      const enemy = {
        name: enemyBase.name,
        maxHp: enemyBase.maxHp,
        hp: enemyBase.hp,
        atk: enemyBase.atk,
        dodge: enemyBase.dodge,
        spd: Math.floor(enemyBase.spd * eff.enemySpeedMul),
        physique: enemyBase.physique,
        root: enemyBase.root
      };

      currentBattle = {
        player: {
          hp: maxHp,
          maxHp,
          atk,
          dodge,
          spd,
          physDef: stats.physique,
          rootDef: stats.root
        },
        enemy,
        turn: 1,
        currentActor: null,
        effects: eff,
        map,
        abilityBefore: abilityPoints,
        expBefore: experience,
        skillState: {}
      };

      battleLogDiv.innerHTML = '';
      battleResultDiv.textContent = '';

      appendBattleLog(`æ¸¸å†å¼€å§‹ï¼ä½ åœ¨ã€Œ${map.name}ã€ä¸ã€Œ${enemy.name}ã€å±•å¼€è¯•ç‚¼ã€‚`);
      if (currentBattle.player.spd >= currentBattle.enemy.spd) {
        currentBattle.currentActor = 'player';
        appendBattleLog('ä½ èº«æ³•æ›´å¿«ï¼Œç‡å…ˆå‡ºæ‰‹ã€‚');
      } else {
        currentBattle.currentActor = 'enemy';
        appendBattleLog(`ã€Œ${enemy.name}ã€å…ˆå‘åˆ¶äººï¼`);
      }

      startBattleBtn.disabled = true;
      battleTimerId = setInterval(runBattleTurn, BATTLE_TURN_DELAY);
    }

    // è‡ªåŠ¨æˆ˜æ–—ï¼šåœ¨æ»¡è¶³æ¡ä»¶æ—¶è‡ªåŠ¨å¼€ä¸€å±€
    function maybeStartAutoBattle() {
      if (!gameStarted) return;
      if (!autoBattle) return;
      if (currentBattle || battleTimerId) return;
      startBattle();
    }

    /* ========== çœŸæ°”è·å– ========== */

    function gainQi(amount, source) {
      if (!gameStarted) return;
      const meta = getLingRootTierMeta();
      const methodMult = getMethodQiMult();
      let finalAmount = amount;
      if (['auto','click','battle','event'].includes(source)) {
        finalAmount *= meta.qiMult * methodMult;
      }

      const oldStage = realmStage;
      qi += finalAmount;
      rollAbilityPoint(source);
      checkBreakthrough();

      if (realmStage > oldStage && currentBattle) {
        appendBattleLog(`åœ¨æ¿€æˆ˜ä¸­ï¼Œä½ ä½“å†…çœŸæ°”æ²¸è…¾ï¼Œå¢ƒç•Œçªç ´è‡³ã€Œ${getRealmNameFromStage(realmStage)}ã€ï¼`);
      }
    }

    /* ========== äº¤äº’ç»‘å®š ========== */

    navItems.forEach(item => {
      item.addEventListener('click', () => {
        const page = item.dataset.page;
        switchPage(page);
      });
    });

    mapSelect.addEventListener('change', () => {
      currentMapId = mapSelect.value;
      saveGame();
    });

    autoBattleToggle.addEventListener('change', () => {
      autoBattle = autoBattleToggle.checked;
      saveGame();

      if (autoBattle) {
        maybeStartAutoBattle();
      }
    });

    cultivateBtn.addEventListener('click', () => {
      gainQi(qiPerClick, 'click');
      updateUI();
    });

    buyCaveBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      const cost = getCaveBuyCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        caveCount += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    upgradeCaveBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      if (caveQuality >= MAX_CAVE_QUALITY) return;
      const cost = getCaveUpgradeCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        caveQuality += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    buyPillBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      const cost = getPillBuyCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        pillLevel += 1;
        recalcDerivedStats();
        updateUI();
      }
    });

    upgradePillBtn.addEventListener('click', () => {
      if (!gameStarted) return;
      if (pillQuality >= MAX_PILL_QUALITY) return;
      const cost = getPillUpgradeCost();
      if (spiritStones >= cost) {
        spiritStones -= cost;
        pillQuality += 1;
        recalcDerivedStats();
        updateUI();
      }
    });


    if (buyWashPillBtn) {
      buyWashPillBtn.addEventListener('click', () => {
        if (!gameStarted) return;
        if (!lingRoots || lingRoots.length === 0) {
          alert('ä½ å°šæœªè§‰é†’ä»»ä½•çµæ ¹ï¼Œæ— æ³•ä½¿ç”¨æ´—é«“ä¸¹ã€‚');
          return;
        }
        const cost = getWashPillCost();
        if (spiritStones < cost) return;
        spiritStones -= cost;
        openWashRootOverlay();
        updateUI();
      });
    }

    plusButtons.forEach(btn => {
      btn.addEventListener('click', () => {
        if (!gameStarted) return;
        const key = btn.dataset.stat;
        if (abilityPoints > 0 && stats[key] != null) {
          abilityPoints--;
          stats[key] += 1;
          updateUI();
        }
      });
    });

    saveBtn.addEventListener('click', () => {
      saveGame();
      updateSaveSlotUI();
      saveBtn.textContent = 'å·²ä¿å­˜ âœ”';
      setTimeout(() => { saveBtn.textContent = 'æ‰‹åŠ¨ä¿å­˜'; }, 1000);
    });

    resetBtn.addEventListener('click', () => {
      if (confirm('ç¡®å®šè¦æ¸…ç©ºå½“å‰å­˜æ¡£æ§½å¹¶ä»å‡¡äººå¢ƒç•Œé‡æ–°ä¿®ç‚¼å—ï¼Ÿï¼ˆä»…å½±å“å½“å‰æ§½ä½ï¼‰')) {
        resetGame();
        updateUI();
        switchPage('cultivation');
      }
    });

    startBattleBtn.addEventListener('click', () => {
      startBattle();
    });

    closeResultBtn.addEventListener('click', () => {
      battleResultOverlay.style.display = 'none';
      updateUI();
      saveGame();
    });

    breakthroughBtn.addEventListener('click', () => {
      doManualBreakthrough();
    });

    // ========== å¼€å±€çµæ ¹æŠ½å–è½¬ç›˜é€»è¾‘ ==========
    function resetRootDrawPanel() {
      tempLingRoots = [];
      rootRollUsed = false;
      rootRerollLeft = 2;
      rootWheelRunning = false;
      if (rootWheelTimer) {
        clearInterval(rootWheelTimer);
        rootWheelTimer = null;
      }
      if (rootRerollLeftSpan) rootRerollLeftSpan.textContent = '2';
      if (rootResultNameSpan) {
        rootResultNameSpan.textContent = 'æœªæŠ½å–';
        applyLingRootColor(rootResultNameSpan, null);
      }
      if (rootResultTierSpan) rootResultTierSpan.textContent = '-';
      if (rootResultDescDiv) rootResultDescDiv.textContent = 'è¯·å…ˆç‚¹å‡»ã€Œå¼€å§‹æŠ½å–ã€ã€‚';
      if (rootWheelName) {
        rootWheelName.textContent = 'ç‚¹å‡»å¼€å§‹è½¬ç›˜';
        applyLingRootColor(rootWheelName, null);
      }
      if (btnRootRoll) btnRootRoll.disabled = false;
      if (btnRootReroll) btnRootReroll.disabled = true;
      if (btnRootConfirm) btnRootConfirm.disabled = true;
    }

    function startRootWheelRoll(onFinish) {
      if (!rootWheelName || rootWheelRunning) return;
      rootWheelRunning = true;
      const all = LING_ROOTS;
      rootWheelTimer = setInterval(() => {
        const r = all[Math.floor(Math.random() * all.length)];
        rootWheelName.textContent = r.name;
        applyLingRootColor(rootWheelName, [r]);
      }, 80);

      const duration = 1000 + Math.random() * 600;
      setTimeout(() => {
        if (rootWheelTimer) {
          clearInterval(rootWheelTimer);
          rootWheelTimer = null;
        }
        rootWheelRunning = false;
        if (typeof onFinish === 'function') onFinish();
      }, duration);
    }

    function updateRootDrawResult() {
      if (!tempLingRoots || tempLingRoots.length === 0) return;
      const displayName = getLingRootDisplayNameFrom(tempLingRoots);

      if (rootResultNameSpan) {
        rootResultNameSpan.textContent = displayName;
        applyLingRootColor(rootResultNameSpan, tempLingRoots);
      }
      if (rootWheelName) {
        rootWheelName.textContent = displayName;
        applyLingRootColor(rootWheelName, tempLingRoots);
      }

      const old = lingRoots;
      lingRoots = tempLingRoots;
      const meta = getLingRootTierMeta();
      lingRoots = old;

      let tierText = meta.label;
      let desc = '';

      if (tempLingRoots.length === 2 && tempLingRoots.every(r => r.type === 'basic')) {
        const rel = getDualBasicRelation(tempLingRoots);
        if (rel && rel.comboName) {
          tierText = `${meta.label} Â· ${rel.comboName}`;
        }
        desc = `${tempLingRoots[0].name} ä¸ ${tempLingRoots[1].name} å¹¶å­˜ã€‚${rel.descExtra || ''}`;
      } else {
        desc = tempLingRoots.map(r => r.desc).join(' / ');
      }

      if (rootResultTierSpan) rootResultTierSpan.textContent = tierText;
      if (rootResultDescDiv) rootResultDescDiv.textContent = desc;
    }

    function resetWashRootPanel() {
      pendingWashLingRoots = [];
      if (washRootResultNameSpan) {
        washRootResultNameSpan.textContent = 'æœªæŠ½å–';
        applyLingRootColor(washRootResultNameSpan, null);
      }
      if (washRootResultTierSpan) washRootResultTierSpan.textContent = '-';
      if (washRootResultDescDiv) washRootResultDescDiv.textContent = 'è¯·å…ˆç‚¹å‡»ã€Œå¼€å§‹è½¬ç›˜ã€ã€‚';
      if (washRootWheelName) {
        washRootWheelName.textContent = 'ç‚¹å‡»å¼€å§‹è½¬ç›˜';
        applyLingRootColor(washRootWheelName, null);
      }
      if (btnWashRootRoll) btnWashRootRoll.disabled = false;
      if (btnWashReplace) btnWashReplace.disabled = true;
      if (washWheelTimer) {
        clearInterval(washWheelTimer);
        washWheelTimer = null;
      }
      washWheelRunning = false;
      if (washConfirmToggle) washConfirmToggle.checked = washConfirmEnabled;
    }

    function startWashRootWheelRoll(onFinish) {
      if (!washRootWheelName || washWheelRunning) return;
      washWheelRunning = true;
      const all = LING_ROOTS;
      washWheelTimer = setInterval(() => {
        const r = all[Math.floor(Math.random() * all.length)];
        washRootWheelName.textContent = r.name;
        applyLingRootColor(washRootWheelName, [r]);
      }, 80);

      const duration = 1000 + Math.random() * 600;
      setTimeout(() => {
        if (washWheelTimer) {
          clearInterval(washWheelTimer);
          washWheelTimer = null;
        }
        washWheelRunning = false;
        if (typeof onFinish === 'function') onFinish();
      }, duration);
    }

    function updateWashRootResult() {
      if (!pendingWashLingRoots || pendingWashLingRoots.length === 0) return;
      const displayName = getLingRootDisplayNameFrom(pendingWashLingRoots);

      if (washRootResultNameSpan) {
        washRootResultNameSpan.textContent = displayName;
        applyLingRootColor(washRootResultNameSpan, pendingWashLingRoots);
      }
      if (washRootWheelName) {
        washRootWheelName.textContent = displayName;
        applyLingRootColor(washRootWheelName, pendingWashLingRoots);
      }

      const old = lingRoots;
      lingRoots = pendingWashLingRoots;
      const meta = getLingRootTierMeta();
      lingRoots = old;

      let tierText = meta.label;
      let desc = '';

      if (pendingWashLingRoots.length === 2 && pendingWashLingRoots.every(r => r.type === 'basic')) {
        const rel = getDualBasicRelation(pendingWashLingRoots);
        if (rel && rel.comboName) {
          tierText = `${meta.label} Â· ${rel.comboName}`;
        }
        desc = `${pendingWashLingRoots[0].name} ä¸ ${pendingWashLingRoots[1].name} å¹¶å­˜ã€‚${(rel && rel.descExtra) || ''}`;
      } else {
        desc = pendingWashLingRoots.map(r => r.desc).join(' / ');
      }

      if (washRootResultTierSpan) washRootResultTierSpan.textContent = tierText;
      if (washRootResultDescDiv) washRootResultDescDiv.textContent = desc;
    }

    function openWashRootOverlay() {
      if (!washRootOverlay) return;
      if (!lingRoots || lingRoots.length === 0) return;
      resetWashRootPanel();
      if (washOldRootNameSpan) {
        washOldRootNameSpan.textContent = getLingRootDisplayName();
        applyLingRootColor(washOldRootNameSpan, lingRoots);
      }
      washRootOverlay.style.display = 'flex';
    }

    startGameBtn.addEventListener('click', () => {
      let name = playerNameInput.value.trim();
      if (!name) name = 'æ— åæ•£ä¿®';
      playerName = name;
      playerNameSpan.textContent = playerName;
      if (rootPlayerNameSpan) {
        rootPlayerNameSpan.textContent = playerName;
      }
      resetRootDrawPanel();
      startScreen.style.display = 'none';
      if (rootDrawPanel) {
        rootDrawPanel.style.display = 'block';
      }
    });

    btnRootRoll.addEventListener('click', () => {
      if (rootRollUsed) return;
      rootRollUsed = true;
      if (btnRootRoll) btnRootRoll.disabled = true;
      if (btnRootReroll) btnRootReroll.disabled = true;
      if (btnRootConfirm) btnRootConfirm.disabled = true;

      startRootWheelRoll(() => {
        tempLingRoots = generateLingRoots();
        updateRootDrawResult();
        if (btnRootConfirm) btnRootConfirm.disabled = false;
        if (rootRerollLeft > 0 && btnRootReroll) btnRootReroll.disabled = false;
      });
    });

    btnRootReroll.addEventListener('click', () => {
      if (rootRerollLeft <= 0) return;
      if (rootWheelRunning) return;
      rootRerollLeft--;
      if (rootRerollLeftSpan) rootRerollLeftSpan.textContent = String(rootRerollLeft);
      if (btnRootReroll) btnRootReroll.disabled = true;
      if (btnRootConfirm) btnRootConfirm.disabled = true;

      startRootWheelRoll(() => {
        tempLingRoots = generateLingRoots();
        updateRootDrawResult();
        if (btnRootConfirm) btnRootConfirm.disabled = false;
        if (rootRerollLeft > 0 && btnRootReroll) btnRootReroll.disabled = false;
      });
    });

    btnRootConfirm.addEventListener('click', () => {
      if (!tempLingRoots || tempLingRoots.length === 0) return;
      lingRoots = tempLingRoots.slice();
      gameStarted = true;
      if (rootDrawPanel) rootDrawPanel.style.display = 'none';
      saveGame();
      updateUI();
      if (autoBattle) {
        maybeStartAutoBattle();
      }
    });

    if (btnWashRootRoll) {
      btnWashRootRoll.addEventListener('click', () => {
        if (washWheelRunning) return;
        btnWashRootRoll.disabled = true;
        if (btnWashReplace) btnWashReplace.disabled = true;

        startWashRootWheelRoll(() => {
          pendingWashLingRoots = generateLingRoots();
          updateWashRootResult();
          btnWashRootRoll.disabled = false;
          if (btnWashReplace) btnWashReplace.disabled = false;
        });
      });
    }

    if (btnWashKeepOld) {
      btnWashKeepOld.addEventListener('click', () => {
        pendingWashLingRoots = [];
        if (washRootOverlay) washRootOverlay.style.display = 'none';
      });
    }

    if (btnWashReplace) {
      btnWashReplace.addEventListener('click', () => {
        if (!pendingWashLingRoots || pendingWashLingRoots.length === 0) return;
        let ok = true;
        if (washConfirmEnabled) {
          ok = window.confirm('ç¡®å®šè¦ç”¨æ–°çš„çµæ ¹æ›¿æ¢åŸæœ¬çš„çµæ ¹å—ï¼Ÿæ­¤æ“ä½œå°†ç«‹å³ç”Ÿæ•ˆï¼Œæ— æ³•æ’¤é”€ã€‚');
        }
        if (!ok) return;
        lingRoots = pendingWashLingRoots.slice();
        pendingWashLingRoots = [];
        recalcDerivedStats();
        updateUI();
        saveGame();
        if (washRootOverlay) washRootOverlay.style.display = 'none';
      });
    }

    if (btnWashClose) {
      btnWashClose.addEventListener('click', () => {
        pendingWashLingRoots = [];
        if (washRootOverlay) washRootOverlay.style.display = 'none';
      });
    }

    if (washConfirmToggle) {
      washConfirmToggle.checked = washConfirmEnabled;
      washConfirmToggle.addEventListener('change', () => {
        washConfirmEnabled = !!washConfirmToggle.checked;
      });
    }

    /* ========== æ”¾ç½®å¾ªç¯ & è‡ªåŠ¨å­˜æ¡£ ========== */

    setInterval(() => {
      if (!gameStarted) return;
      gainQi(qiPerSecond, 'auto');
      updateUI();
    }, 1000);

    setInterval(() => {
      if (!gameStarted) return;
      saveGame();
    }, 5000);

    /* ========== åˆå§‹åŒ– ========== */

    generateMaps();
    loadGameAtStartup();
    initMaps();

    if (playerName && playerName.trim()) {
      gameStarted = true;
      startScreen.style.display = 'none';
    } else {
      gameStarted = false;
      startScreen.style.display = 'flex';
    }

    switchPage('cultivation');
    updateUI();

    if (gameStarted && autoBattle) {
      maybeStartAutoBattle();
    }
  </script>
</body>
</html>






